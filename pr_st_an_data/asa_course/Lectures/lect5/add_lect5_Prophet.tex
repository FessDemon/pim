%encoding=utf8%
\documentclass[a4paper,14pt]{extarticle}

% Русская кодировка
\usepackage[T2A]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[russian]{babel}

\usepackage[pdftex]{graphicx}
\usepackage[pdftex,colorlinks,urlcolor=blue, citecolor=magenta]{hyperref}
%        \pdfcompresslevel=9 % сжимать PDF

% необходимые модули
\usepackage{amssymb,amsmath,amsthm}
\usepackage{indentfirst}
\usepackage{tikz}
\usepackage[margin=10mm, includefoot]{geometry}
\usepackage[inline]{enumitem}
\setlist{noitemsep,leftmargin=\parindent}

\AddEnumerateCounter{\Asbuk}{\@Asbuk}{\CYRM}
\AddEnumerateCounter{\asbuk}{\@asbuk}{\cyrm}
\newlist{dotenumerate}{enumerate}{10}
\setlist[enumerate,1]{label=\arabic*., ref=\arabic*} %списки со скобками
\setlist[enumerate,2]{label=\asbuk*), ref=(\asbuk*)} %списки со скобками

\usepackage{tabularx}
\newcolumntype{C}{>{\centering\arraybackslash}X}


%Полуторный интервал
\renewcommand{\baselinestretch}{1.00}
\title{К лекции 5. Модель Prophet}
\author{Д.\,В. Чупраков}
\date{13 февраля 2024 г.}
\begin{document}
\maketitle



\section{Модель prophet}

В 2017 г. специалисты компании Facebook объявили о разработанном ими новом пакете для прогнозирования временных рядов — prophet (<<пророк>>), который позволяет создавать прогнозные модели в (полу–)автоматическом режиме. 

Подробное описание реализованной в prophet методологии можно найти в статье \href{http://lethalletham.com/ForecastingAtScale.pdf}{Taylor and Letham (2017)}\footnote{Taylor, S. J., Letham, B. (2017). Forecasting at Scale. The American Statistician, 72(1), 37–45. doi:10.1080/00031305.2017.1380080  URL: \url{http://lethalletham.com/ForecastingAtScale.pdf}}. 

В основе этой методологии лежит процедура подгонки аддитивных регрессионных моделей (Generalized Additive Models, GAM) следующего вида: 
$$
    y(t)=g(t)+s(t)+h(t)+x(t)+\varepsilon_t,
$$
где $g(t)$~--- функция, аппроксимирующая тренд ряда, $s(t)$~--- функции, описывающая сезонные колебания (например, годовые, недельные и т.п.) соответственно, $h(t)$~--- функция, отражающая эффекты праздников и других изолированных, но оказывающих существенное влияние событий,
$x(t)$~--- функция, отражающая влияние внешних регрессоров, $\varepsilon_t$~--- нормально распределенные случайные возмущения. 

\subsection{Модель тренда}

Тренд в модели Prophet описывается кусочно-логистической функцией
$$
    g(t) = \frac{C(t)}{1+e^{-k(t)\cdot (t-m(t))}}
$$
где 
$C(t)$~--- верхний порог (емкость источника) в момент времени $t$, $k$~--- скорость роста, $m$~--- параметр смещения, если временной ряд демонстрирует кумулятивный роста подобный модели роста населения и кусочно-линейной функцией:
$$
    g(t) = kt+m,
$$
если кумулятивного роста не наблюдаетмся.
 
Изменения вида тренда происходят в моменты времени  $s_1, s_2, \ldots s_S$.

Введем вектор корректировок скорости $\delta \in \mathbb{R}^S$, где $\delta_j$~--- изменение скорости роста временного ряда, наблюдаемое в момент времени~$s_j$. 
Тогда скорость изменения тренда в каждый момент времени $t$ получается из базовой скорости $k$ прибавлением всех 
корректировое до этого момента: 
$$
v_t = k + \sum_{j: t>s_j} \delta_j = k + a(t)^T\delta
$$
где вектор $a(t) \in \{0, 1\}^S$ задан своими компонентами по следующей формуле:
$$
    \vec{a}_j(t) = 
    \begin{cases}
        1,& t \geqslant s_j\\
        0,& t < s_j\\
    \end{cases}
$$

Аналогично смещение в точке изменения $s_j$ легко вычисляется по формуле
$$
    \gamma_j = \Big(s_j -m - \sum_{l<j} \gamma_l \Big) \frac{\delta_j}{k+\sum\limits_{l\leqslant j} \delta_l}
$$




Итак, функция тренда на каждом промежутке имеет один из видов:
\begin{align*}
    g(t) &= \frac{C(t)}{1+\exp\left(- \big(k+\vec{a}(t)^T\vec{\delta}\,\big) \big(t-(m+\vec{a}(t)^T\vec{\gamma}\,\big)\right)}\\
    g(t) &= \big(k + \vec{a}(t)^T\vec\delta\big)\cdot t + \big(m + \vec{a}(t)T\vec{\gamma}\big), 
\end{align*}
где вектор $\vec{\gamma}$ определен покомпонентно равенствами $\gamma_j = -s_j\delta_j$ чтобы обеспечить непрерывность функции тренда.


Точки изменения $s_j$ могут быть  явно заданы исследователем, на основе знания событий, влияющих на динамику исследуемого процесса или могут быть автоматически выбраны из набора кандидатов.

При автоматическом выборе точек изменения тренда оценивается вектор $\vec{\delta}$ в предположении, что его компоненты распределены по закону Лапласа: $\delta_j \sim \mathop{\mathrm{Laplace}}(0,\tau)$. 
Параметр $\tau$ управляет
гибкостью модели при изменении ее скорости. 
если $\tau$ стремится к 0, то тренд вырождается в не кусочную логистическую или линейную функцию.


Будущие изменения скорости, которые имитируют изменения в прошлом, определяя параметр~$\tau$ методами байесовской статистики: методом нахождения апостериорного максимума (MAP) и путем полного байесовского вывода. 


% В полностью байесовской структуре это можно было бы сделать с иерархическим априором по τ
% , чтобы получить его апостериор, в противном случае мы можем использовать оценку максимального правдоподобия

% Параметра шкалы скорости: 
% $$
% \lambda = \frac{1}{S} \sum_{j=1}^S |\delta_j|
% $$

Точки изменения тренда выбираются случайным образом так, чтобы средняя частота точек изменений  совпадала с таковой в истории. То есть $\delta_j \sim \mathop{\mathrm{Laplace}}(0,\tau)$ c~верятностью $\frac{S}{T}$ и $\delta_j=0$ с вероятностью $1-\frac{S}{T}$.

\subsection{Cезонность}

Временные ряды часто имеют многопериодную сезонность.
Например, рабочий график обеспечивает недельную сезонность, а климатические факторы~--- годовую.

Чтобы обеспечить учет сезонностей с разными периодами Функция сезонности представляется в виде  отрезка ряда Фурье:
$$
s(t) = \sum_{n=1}^N\left(a_n \cos \frac{2\pi n t}{P} + b_n \sin \frac{2\pi n t}{P}\right)
$$
где $P$~--- регулярный период, который, как мы ожидаем, будет иметь временной ряд (например, $P = 365.25$ для годовых данных или $P = 7$ для недельных данных).

Таким образом функция сезонной компоненты может быть представлена в векторном виде 
$s(t) = \vec{X}(t) \cdot \vec{\beta}^T$ 
где 
\begin{align*}
\vec{X}(t) &= \left( \cos \frac{2\pi\cdot 1 \cdot t}{P},\sin \frac{2\pi\cdot 1 \cdot t}{P}, \ldots, \cos\frac{2\pi\cdot N \cdot t}{P},\sin \frac{2\pi\cdot N \cdot t}{P}\right)\\
\vec{\beta} &= (a_1,b_1,\ldots a_N, b_N)
\end{align*}
Иными словами, вычисление функции сезонности требует оценки $2N$ параметров? что делается путем построения матрицы векторов сезонности для каждого значения $t$ в исторических данных.


Элементы вектора $\vec\beta$ берутся из нормального распределения $N(0, \sigma ^2)$.

Усечение ряда до $N$ компонент реализует фильтр высоких частот поэтому числа частот ведет к повышенному риску переобучения, но позволяет моделировать быстро меняющиеся процессы. Эмпирически для годовой и недельной сезонности подходят значения $N = 10$ и $N = 3$ соответственно.
Выбор этих параметров может быть автоматизирован с помощью
информационных критериев качества модели, например AIC.

\subsection{Праздники}

Праздники и события вызывают значительные, в некоторой степени предсказуемые изменения во многих временных
рядах бизнеса и часто не следуют периодической схеме (праздники по лунному календарю, фестивали и т.\, д., презентации новых товаров и т.\,д.), поэтому их последствия плохо моделируются тригонометрическими функциями.
В то же время влияние конкретного праздника на временные ряды часто бывает одинаковым из года в год, поэтому
важно учитывать это в прогнозе.

Будем считать, что все праздники незавимсимы. Поэтому, для каждого праздника $i$ пусть $D_i$~--- набор прошлых
и будущих дат для этого праздника. 
Рассмотрим характеристическую функцию $\mathbf{1}(t \in D)$ для каждого праздника $D$ cопоставляющую моменту времени наличие праздника. присваиваем каждому празднику параметр $\vec\kappa_i$,характеризующий изменение в прогнозе. 
Это делается аналогично сезонности путем генерации матрицы
регрессоров
$$
Z(t) = (\mathbf{1}(t \in D_1),\ldots, \mathbf{1}(t \in D_L))
$$
и найдем $h(t) = Z(t)\cdot\vec{\kappa}^T$
Как и в случае с сезонностью, используются нормально распределенные значения $\kappa$ c нулевым математическим ожиданием.


\section{Интерфейс Prophet}

\paragraph{Установка:}
\verb"python -m pip install prophet" или \verb"conda install -c conda-forge prophet"
Пакет до версии 1.0 носил название \texttt{fbprophet} поэтому в сети много информации именно под такое написание пакета. Ставить же надо пакет prophet.

\paragraph{Структура входного файла:}
Формат обучающей выборки имеет два обязательных поля \texttt{xs}~--- временная метка и \texttt{y} - значение уровня. Остальные поля являются полями внешних признаков.
Также возможно указатние емкости источника --- столбец~\texttt{cap}.

\paragraph{Структура файла праздников:}


\paragraph{Структура конструктора класса Prophet:}~\par

Модель Prophet подключается стандартно: \texttt{from prophet import Prophet}
Аргументы конструктора следующие:

\begin{itemize}
    \item \texttt{growth}~--- тип тренда: \texttt{linear}, \texttt{logistic}  или \texttt{flat}
    \item \texttt{yearly\_seasonality}, \texttt{weekly\_seasonality},  \texttt{daily\_seasonality}~ --- виды сезонностей: принимает логическое значение, число компонент в ряде Фурье или \texttt{'auto'}.
    \item  \texttt{holidays}~--- таблица праздников.
    \item \texttt{seasonality\_mode} и \texttt{holidays\_mode} тип сезонности и праздников: \texttt{'additive'}, \texttt{'multiplicative'}.
    \item \texttt{seasonality\_prior\_scale}, \texttt{holidays\_prior\_scale} --- определяют силу соответствующей компоненты
    Большие значения приводят к большему влиянию соответствующей компоненты
    \item \texttt{changepoints}~--- список точек изменения тренда
    \item \texttt{n\_changepoints}~--- число точек изменения тренда
    \item \texttt{changepoint\_range}: Доля исторических данных, в которой будут искаться точки изменения тренда - число от 0 до 1по умолчанию~--- 0.8.
    \item \texttt{changepoint\_prior\_scale}~--- Параметр, регулирующий гибкость автоматического выбора точки изменения. С увеличением значения увеличивается число точек изменения тренда.

    \item \texttt{mcmc\_samples}~--- число итераций байесовского вывода. если 0, то используется алгоритм MAP оценки.
\end{itemize}


\small
Полезное:
\begin{verbatim}
    from prophet.diagnostics import cross_validation, performance_metrics
    from prophet.plot import plot_cross_validation_metric
    plot_cross_validation_metric(df_cv, metric = 'rmse');
    df_cv = cross_validation(m,
    horizon = '31 days', period = '16 days', initial = '365 days', parallel = 'processes')            
    m.add_regressor('regressor_1')
    model.add_seasonality(name='weekly_on_winter', 
    period=7, fourier_order=3, condition_name='зима')

\end{verbatim}

\end{document}








Для этого применяется платформа вероятностного программирования Stan. 




Пакет prophet представляет собой ни что иное, как удобный интерфейс для работы с этой платформой



6.2 Первый простой пример

Для иллюстрации особенностей работы с пакетом prophet воспользуемся набором данных bitcoin, в котором хранятся исторические данные по стоимости биткоина на момент закрытия торгов (подразд. 1.5.2). Стоимость биткоина — не самая простая переменная для моделирования (что справедливо для подавляющего большинства финансовых временных рядов). Этот ряд обладает сложным трендом, дисперсия его значений возрастает со временем, имеют место резкие изменения уровней, вероятно сопряженные с какими–то (в большинстве случаев неизвестными нам) особыми событиями (рис. 1.3). Тем не менее, это хороший пример реальных данных, с которыми аналитик может столкнуться на практике. Тем интереснее будет посмотреть, как с задачей прогнозирования этого ряда справится prophet!

Предположим, что нам необходимо сделать прогноз стоимости биткоина на следующие 90 дней. Приведенный ниже код выполняет подготовку данных для построения подобной модели: сначала происходит логарифмирование значений стоимости биткоина y (для снижения дисперсии), а затем разбиение исходной выборки на обучающую (все наблюдения за исключением последних 90 дней) и проверочную (последние 90 дней).

Обратите внимание также на замену класса итоговых таблиц bitcoin_train и bitcoin_test с tsibble на стандартный data.frame — это обусловлено тем, что в настоящее время функции пакета prophet, к сожалению, не могут корректно работать с данными в формате tsibble.

bitcoin_train <- bitcoin %>%
  mutate(y = log(y)) %>% 
  slice(1:(n() - 90)) %>% 
  as.data.frame()

bitcoin_test <- bitcoin %>% 
  mutate(y = log(y), ds = as.Date(ds)) %>%
  tail(90) %>% 
  as.data.frame()

Подгонку моделей с разными параметрами мы будем выполнять на обучающих данных (bitcoin_train). Проверочная выборка (bitcoin_test) пригодится в самом конце процесса моделирования, чтобы выяснить насколько наши ожидания в отношении качества выбранной оптимальной модели соответствуют действительности. Заметьте, что в обеих этих таблицах столбец с датами обозначен как ds, а столбец со значениями отклика как y. Это условные обозначения, принятые в prophet. Использование каких–либо других имен приведет к ошибке при вызове соответствующих функций.

Обучающие данные, подготовленные описанным выше способом, представлены на рис. 6.1.

bitcoin_train %>% 
  ggplot(., aes(ds, y)) +
  geom_line() +
  theme_minimal()

Обучающие данные по стоимости биткоина

РИСУНОК 6.1: Обучающие данные по стоимости биткоина

Нашу первую модель (обозначим ее M0) мы построим с использованием параметров, принятых в prophet по умолчанию. Для этого потребуется всего одна строка кода:

require(prophet)
M0 <- prophet(bitcoin_train)

Объект M0 представляет собой большой список (выполните команду str(M0), чтобы просмотреть его структуру). Для получения прогноза на основе этой модели необходимо сначала воспользоваться функцией make_future_dataframe() и создать таблицу с датами, охватывающими необходимый временной промежуток в будущем (“горизонт”), а затем подать эту таблицу вместе с модельным объектом на функцию predict():

future_df <- make_future_dataframe(M0, periods = 90)
forecast_M0 <- predict(M0, future_df)

Объект forecast_M0 — это обычная таблица, в которой хранятся значения нескольких рассчитанных на основе модели M0 величин, включая компоненты модели (см. разд. 6.1), предсказанные значения отклика, а также верхние и нижние границы доверительных интервалов соответствующих величин. Вот так, например, выглядят первые несколько предсказанных значений стоимости биткоина и их (принятые по умолчанию) 80%–ные доверительные границы:

forecast_M0 %>% 
  dplyr::select(yhat, yhat_lower, yhat_upper) %>% head()

##       yhat yhat_lower yhat_upper
## 1 6.134964   6.024296   6.230752
## 2 6.134025   6.034873   6.237148
## 3 6.127710   6.026591   6.232882
## 4 6.124329   6.018906   6.227581
## 5 6.119314   6.008620   6.227911
## 6 6.111687   6.006040   6.218552

Таблицу forecast_M0 и объект M0 далее можно подать на функцию plot(), чтобы изобразить подогнанную модель и прогнозные значения на графике (рис. 6.2):

plot(M0, forecast_M0)

Прогноз стоимости биткоина, полученный на основе модели M0

РИСУНОК 6.2: Прогноз стоимости биткоина, полученный на основе модели M0

Точки на рис. 6.2 соответствуют (логарифмированным) значениям стоимости биткоина из обучающей выборки. Сплошная голубая линия — это предсказанные моделью значения стоимости, а огибающая эту линию светло–голубая “лента” обозначает 80%–ные доверительные границы предсказанных значений. Прогнозные значения у на следующие 90 дней видны в правой части графика.

С помощью функции prophet_plot_components() мы можем также изобразить отдельные компоненты модели (рис. 6.3):

prophet_plot_components(M0, forecast_M0)

Компоненты модели M0

РИСУНОК 6.3: Компоненты модели M0

На рис. 6.3 видно, что модель M0 хорошо передает имеющийся в данных сложный тренд. Видно также, что в этом временном ряду есть очень слабо выраженные внутригодовые колебания и практически несуществующие колебания в пределах недели (обратите внимание на шкалы ординат этих трех графиков, которые помогают оценить вклад каждой из компонент).

Для создания модели M0 потребовалась всего одна строка кода и процесс подгонки занял пару секунд. Учитывая, что анализируемый нами временной ряд не самый простой для моделирования, полученная модель довольно хорошо передает свойства этого ряда. Возможность быстро и удобно создавать такие качественные модели в автоматическом режиме является основным преимуществом prophet.

Тем не менее, качество прогноза M0 оставляет желать лучшего. На данном этапе моделирования главным признаком неудовлетворительного качества предсказаний M0 является чрезмерно расширяющиеся доверительные границы прогнозных значений (рис. 6.3). В следующих разделах мы постараемся улучшить эту базовую модель путем добавления предикторов и настройки параметров функции prophet().
6.3 Функция prophet()

Ниже приведено описание основных аргументов функции prophet(), с которой мы познакомились в предыдущем разделе:

    df — необязательный аргумент, с помощью которого указывают таблицу с историческими данными. Такая таблица должна содержать как минимум два столбца: ds (даты в формате YYYY-MM-DD) и y (значения моделируемого отклика). В случаях, когда тренд в y моделируется как логистический рост, таблица с историческими данными должна также содержать столбец cap (“емкость”), который соответствует максимально достижимым значениям y для соответствующих дат. Если аргумент df не указан (NULL), то произойдет только инициализация модельного объекта, а для непосредственного запуска подгонки модели необходимо будет воспользоваться функцией fit.profit(m, df).
    growth — тип тренда. Принимает два возможных значения: "linear" (“линейный”, присвоено по умолчанию) и "logistic" (“логистический”).
    changepoints — текстовый вектор с датами (в формате YYYY-MM-DD), соответствующими “переломным моментам”, или “точкам излома” в y (т.е. датам, когда произошли существенные изменения в тренде временного ряда). Если вектор changepoints не указан, то такие переломные моменты будут оценены автоматически.
    n.changepoints — предполагаемое количество “переломных моментов” (25 по умолчанию). Если аргумент changepoints задан, то аргумент n.changepoints будет проигнорирован. Если же changepoints не задан, то n.changepoints потенциальных точек излома будут распределены равномерно в пределах исторического отрезка, задаваемого аргументом changepoint.range.
    changepoint.range — доля исторических данных (начиная с самого первого наблюдения), по которым будут оценены точки излома. По умолчанию составляет 0.8 (т.е. 80% наблюдений).
    yearly.seasonality — параметр настройки годовой сезонности (т.е. закономерных колебаний в пределах года). Принимает следующие возможные значения: "auto" (автоматический режим, принят по умолчанию), TRUE, FALSE или количество членов ряда Фурье, с помощью которого аппроксимируется компонента годовой сезонности.
    weekly.seasonality — параметр настройки недельной сезонности (т.е. закономерных колебаний в пределах недели). Возможные значения те же, что и у yearly.seasonality.
    daily.seasonality — параметр настройки дневной сезонности (т.е. закономерных колебаний в пределах дня). Возможные значения те же, что и у yearly.seasonality.
    holidays — таблица, содержащая два обязательных столбца: holiday (текстовая переменная с названиями “праздников” и других важных событий, потенциально влияющих на свойства временного ряда) и ds (даты). По желанию в такую таблицу можно добавить еще два столбца — lower_window и upper_window, которые задают отрезок времени вокруг соответствующего события. Так, например, при "lower_window = -2" в модель будут добавлены 2 дня, предшествующие соответствующему событию. По желанию можно также добавить столбец prior_scale — априорное значение стандартного отклонения (нормального) распределения, с помощью которого моделируется эффект того или иного события.
    seasonality.mode — режим моделирования сезонных компонент. Принимает два возможных значения: "additive" (аддитивный, задан по умолчанию) и "multiplicative" (мультипликативный).
    seasonality.prior.scale — параметр, определяющий выраженность сезонных компонент модели (10 по умолчанию). Более высокие значения приведут к более “гибкой” модели, а низкие — к модели со слабее выраженными сезонными эффектами. Этот параметр можно задать отдельно для каждого типа сезонности с помощью функции add_seasonality().
    holidays.prior.scale — параметр, определяющий выраженность эффектов “праздников” и других важных событий (10 по умолчанию). Если таблица, подаваемая на аргумент holidays, имеет столбец prior_scale (см. выше), то аргумент holidays.prior.scale будет проигнорирован.
    changepoint.prior.scale — параметр, задающий чувствительность автоматического механизма обнаружения точек излома в тренде временного ряда y (0.05 по умолчанию). Более высокие значение позволят иметь больше таких точек излома (что одновременно увеличит риск переобучения модели).
    mcmc.samples — целое число (0 по умолчанию). Если >0, то параметры модели будут оценены путем полного байесовского анализа с использованием mcmc.samples итераций алгоритма MCMC (процесс подгонки модели при этом может существенно замедлиться).
    interval.width — число, определяющее ширину доверительного интервала для предсказанных моделью значений (0.8 по умолчанию, что соответствует 80%–ному интервалу). При "mcmc.samples = 0" этот интервал будет оценен с использованием MAP–метода и только на основе неопределенности в отношении тренда в у. Если же mcmc.samples >0, то доверительные интервалы будут оцениваться с учетом неопределенности в отношении оценок всех параметров модели (включая сезонные компоненты).
    uncertainty.samples — число итераций для оценивания доверительных интервалов (1000 по умолчанию).
    fit — логическое значение (TRUE по умолчанию). При fit = FALSE произойдет только инициализация модельного объекта, но подгонка модели не запустится.
    ... — дополнительные параметры, которые передаются на функцию fit.prophet().

6.4 Точки излома тренда

Как было отмечено в предыдущем разделе, аналитик может задать точки излома либо самостоятельно (с помощью аргумента changepoints функции prophet()), либо довериться их автоматическому обнаружению. Рассмотрим, как работает каждый из этих режимов, и что происходит в результате изменения соответствующих аргументов функции prophet().

В автоматическом режиме при инициализации модели 25 потенциальных точек излома равномерно распределяются в пределах интервала, который охватывает первые 80% наблюдений из обучающей выборки. Именно это произошло, когда мы построили базовую модель М0 в разд. 6.2. Однако эти 25 точек — лишь предполагаемые места существенных изменений в тренде: в большинстве случаев на практике тренд временного ряда не изменяется так часто. Поэтому в ходе подгонки модели срабатывает механизм регуляризации (подобный l1

–регуляризации), в результате чего выбирается минимально необходимое количество точек излома. Изобразить эти автоматически обнаруженные точки излома можно с помощью функции add_changepoints_to_plot(). Так, для модели M0 получаем (рис. 6.4):

plot(M0, forecast_M0) + add_changepoints_to_plot(M0)

Точки излома тренда, оцененные в результате подгонки модели M0. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

РИСУНОК 6.4: Точки излома тренда, оцененные в результате подгонки модели M0. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

Судя по полученному графику, модель M0 все еще переоценивает количество “переломных моментов” в тренде. Построим новую модель, которая будет инициализирована с меньшим начальным количеством потенциальных точек излома (15 вместо 25; рис. 6.5):

M1 <- prophet(bitcoin_train, n.changepoints = 15)

forecast_M1 <- predict(M1, future_df)
plot(M1, forecast_M1) + add_changepoints_to_plot(M1)

Точки излома тренда, оцененные в результате подгонки модели M1. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

РИСУНОК 6.5: Точки излома тренда, оцененные в результате подгонки модели M1. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

Как и ожидалось, оцененный тренд получился более гладким, чем в модели M0. Хорошо это или плохо, мы узнаем позже, когда рассмотрим диагностику качества моделей с помощью перекрестной проверки (разд. 6.8).

Помимо изменения начального количества потенциальных точек излома тренда мы можем также изменить временной интервал, в пределах которого происходит их оценивание. По умолчанию этот интервал охватывает первые 80% наблюдений. Однако из приведенных выше графиков видно, что примерно в начале ноября 2018 г. произошло резкое падение стоимости биткоина. Ни одна из построенных нами моделей пока не учла это изменение, поскольку оно не вошло в интервал, в пределах которого происходило оценивание точек излома. Увеличим этот интервал до 90%, воспользовавшись аргументом changepoint.range (одновременно увеличим количество потенциальных точек излома с 15 до 20, поскольку на большем промежутке времени можно ожидать больше перепадов в тренде):

M2 <- prophet(bitcoin_train, 
              n.changepoints = 20, 
              changepoint.range = 0.9)

forecast_M2 <- predict(M2, future_df)
plot(M2, forecast_M2) + add_changepoints_to_plot(M2)

Точки излома тренда, оцененные в результате подгонки модели M2. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

РИСУНОК 6.6: Точки излома тренда, оцененные в результате подгонки модели M2. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

Как видно на рис. 6.6, полученная модель M2 намного лучше передает свойства анализируемого временного ряда. Это касается и получаемого с ее помощью прогноза (как с точки зрения направления тренда, так и с точки зрения ширины доверительных границ предсказанных значений).

Еще один параметр для настройки гладкости тренда в моделируемом временном ряду — это changepoint.prior.scale. Чем больше значение этого параметра (по сравнению с принятым по умолчанию значением 0.05), тем больше точек излома останется в полученной модели. Рассмотрим эффект действия changepoint.prior.scale на следующем примере (рис. 6.7):

# В этой модели мы увеличиваем интервал, в пределах которого
# оцениваются точки излома тренда (до 90%), одновременно увеличивая
# уровень регуляризации с помощью параметра changepoint.prior.scale.
# Начальное количество потенциальных точек излома оставим равным 
# значению, принятому по умолчанию (25):

M3 <- prophet(bitcoin_train, 
              changepoint.range = 0.9, 
              changepoint.prior.scale = 0.02)

forecast_M3 <- predict(M3, future_df)
plot(M3, forecast_M3) + add_changepoints_to_plot(M3)

Точки излома тренда, оцененные в результате подгонки модели M3. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

РИСУНОК 6.7: Точки излома тренда, оцененные в результате подгонки модели M3. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

Как видим, модели M2 и M3 дают похожие результаты, что скорее определяется значением параметра changepoint.range, нежели способом регуляризации количества точек излома.

Наконец, посмотрим, что получится, если задать точки излома тренда “вручную”, а не оценивать их в автоматическом режиме. Для этого служит аргумент changepoints (рис. 6.8):

# Здесь мы задаем точки излома тренда самостоятельно
# (выбор дат, подаваемых на аргумент changepoints, основан на
# визуальном анализе обучающих данных):

M4 <- prophet(bitcoin_train, 
              changepoints = c("2016-04-01", "2016-06-15",
                               "2016-10-01", "2017-04-01",
                               "2017-07-01", "2017-09-01",
                               "2017-12-26", "2018-04-01",
                               "2018-11-13", "2018-12-15",
                               "2019-04-01"))

forecast_M4 <- predict(M4, future_df)
plot(M4, forecast_M4) + add_changepoints_to_plot(M4)

Точки излома тренда, оцененные в результате подгонки модели M4. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

РИСУНОК 6.8: Точки излома тренда, оцененные в результате подгонки модели M4. Сплошная красная линия — тренд. Штриховые красные линии — точки излома тренда

Модель M4 хорошо описывает тренд в анализируемом временном ряду, хотя не исключено, что она несколько переобучена.
6.5 Эффекты праздников и других важных событий

Продолжим начатое ранее знакомство с параметрами функции prophet() и рассмотрим способы моделирования эффектов “праздников”. Употребляемый здесь термин “праздник” — результат прямого перевода термина “holiday”, принятого в пакете prophet. Под этим термином мы будем понимать как настоящие официальные праздничные и выходные дни (например, Новый год, Рождество и т.п.), так и другие события, сопровождающиеся заметными изменениями свойств временного ряда (спортивные или культурные мероприятия, природные явления, политические события и т.п.). Поэтому слова “праздник” и “событие” будут применяться ниже как синонимы.
6.5.1 Формат представления

Как было отмечено в разд. 6.3, для добавления эффектов праздников в prophet–модель необходимо сначала создать отдельную таблицу, содержащую как минимум два обязательных столбца: holiday (названия праздников и других событий) и ds (временные метки; обычно это даты в формате YYYY-MM-DD). Важно, чтобы в такую таблицу входил как исторический период, на основе которого происходит обучение модели, так и период в будущем, для которого необходимо сделать прогноз. Например, если какое–то важное событие встречается в обучающих данных, то его следует указать и для прогнозного периода (при условии, конечно, что мы ожидаем повторение этого события в будущем, и что дата этого события входит в прогнозный период).

История биткоина полна событий, которые косвенно или непосредственно оказали влияние на стоимость этой криптовалюты (см. также [здесь](https://en.wikipedia.org/wiki/History_of_bitcoin)). В качестве примера, возьмем некоторые из этих событий:

# event_1 - cоздание Bitcoin Cash
# event_2 - запрет ICO в Китае
# event_3 - новые правила торгов в Ю. Корее
# event_4 - удаление южнокорейского рынка из трекера CoinMarketCap
# event_5 - разветвление Bitcoin Cash

key_dates <- dplyr::tibble(
  holiday = paste0("event_", 1:5),
  ds = as.Date(c("2017-08-01",
                 "2017-09-04",
                 "2017-12-28",
                 "2018-01-08",
                 "2018-11-15"))
  )

Теперь добавим эти события в модель (аргумент holidays):

M5 <- prophet(bitcoin_train, 
              holidays = key_dates,
              changepoint.range = 0.9)

forecast_M5 <- predict(M5, future_df)
prophet_plot_components(M5, forecast_M5)

Оцененные компоненты модели M5

РИСУНОК 6.9: Оцененные компоненты модели M5

На рис. 6.9 приведены оцененные компоненты модели M5, включая эффекты событий, которые были добавлены с помощью аргумента holidays (см. второй график сверху). Функция plot_forecast_component() позволяет изобразить эффекты отдельных событий (см. аргумент name; рис. 6.10):

plot_forecast_component(M5, forecast_M5, name = "event_5")

Эффект разветвления Bitcoin Cash на Bitcoin Cash SV и Bitcoing Cash ABC (event_5), оцененный с помощью модели M5

РИСУНОК 6.10: Эффект разветвления Bitcoin Cash на Bitcoin Cash SV и Bitcoing Cash ABC (event_5), оцененный с помощью модели M5

На аргумент name функции plot_forecast_component() можно также подать значение "holidays", что приведет к изображению на отдельном графике эффектов всех включенных в модель событий (рис. 6.11):

plot_forecast_component(M5, forecast_M5, name = "holidays")

Эффекты всех событий, включенных в модель M5

РИСУНОК 6.11: Эффекты всех событий, включенных в модель M5

О наступлении некоторых событий в истории биткоина было известно заранее, как например о разветвлении Bitcoin Cash на Bitcoin Cash SV и Bitcoin Cash ABC (event_5 в модели M5). Поэтому многие спекулянты начали скупать Bitcoin Cash за несколько дней до “вилки”, или “форка”, чтобы впоследствии удвоить свой капитал (при наступлении “форка” владелец старой монеты автоматически становится владельцем и новой монеты). В связи с этим имело бы смысл моделировать event_5 как событие c “предысторией”, т.е. как событие, чей эффект начал проявлять себя за несколько дней до главной даты (в данном случае 15 ноября 2018 г.). В пакете prophet это можно сделать, добавив в таблицу с моделируемыми событиями столбцы lower_window (определят длительность “предыстории”) и upper_window (определяет длительность эффекта после главной даты). Для примера предположим, что спекулянты начали скупать Bitcoin Cash за две недели до “вилки” (lower_window = -14) и прекратили делать это сразу после “вилки” (upper_window = 0):

key_dates2 <- dplyr::bind_cols(key_dates, 
                               lower_window = c(0, 0, 0, 0, -14),
                               upper_window = c(0, 0, 0, 0, 0))

M6 <- prophet(bitcoin_train,
              holidays = key_dates2,
              changepoint.range = 0.9)
forecast_M6 <- predict(M6, future_df)

# Эффект события с "предысторией":
plot_forecast_component(M6, forecast_M6, name = "event_5")

Эффект события с предысторией

РИСУНОК 6.12: Эффект события с предысторией

Как видно на рис. 6.12, теперь эффект event_5 включает несколько дней до главной даты этого события (сравните с рис. 6.10).
6.5.2 Встроенные даты праздников

До этого момента мы моделировали эффекты событий, которые случались только один раз. Однако многие события, такие как официальные государственные праздники и выходные дни, повторяются регулярно и их эффекты также могут оказаться важными для прогноза.

Конечно, мы могли бы воспользоваться описанным выше способом для включения таких событий в модель, т.е. путем создания таблицы, подобной key_dates или key_dates2. К счастью, в большинстве случаев в этом не будет необходимости — в prophet уже включены даты официальных праздников и выходных дней для более чем 60 стран (полный список можно найти на сайте с официальной документацией по пакету). Эти встроенные даты праздников охватывают период с 1995 по 2044 гг. Для их добавления в модель служит функция add_country_holidays(), которая принимает два аргумента: m (модельный объект) и country_name (международное обозначение страны, например "Russia" или "RU"). Для примера построим модель, которая включает как рассмотренные выше важные в истории биткоина разовые события, так и регулярные официальные праздники США:

# Обратите внимание: здесь мы инициализируем объект M7,
# но пока не подаем на него таблицу с обучающими данными
M7 <- prophet(holidays = key_dates2, changepoint.range = 0.9)

# Добавляем официальные праздничные дни США:
M7 <- add_country_holidays(m = M7, country_name = 'US')

# Обратите внимание на использование функции fit.prophet():
M7 <- fit.prophet(M7, bitcoin_train)
forecast_M7 <- predict(M7, future_df)

plot_forecast_component(M7, forecast_M7, name = "holidays")

Эффекты разовых событий и официальных праздников США, оцененные с помощью модели M7

РИСУНОК 6.13: Эффекты разовых событий и официальных праздников США, оцененные с помощью модели M7

Оцененные эффекты всех событий из модели M7 показаны на рис. 6.13. Просмотреть названия этих событий можно следующим образом:

M7$train.holiday.names

##  [1] "event_1"                     "event_2"                    
##  [3] "event_3"                     "event_4"                    
##  [5] "event_5"                     "New Year's Day"             
##  [7] "Martin Luther King, Jr. Day" "Washington's Birthday"      
##  [9] "Memorial Day"                "Independence Day"           
## [11] "Labor Day"                   "Columbus Day"               
## [13] "Veterans Day"                "Thanksgiving"               
## [15] "Christmas Day"               "Christmas Day (Observed)"   
## [17] "New Year's Day (Observed)"   "Veterans Day (Observed)"

6.5.3 Регуляризация

В пакете prophet имеется возможность подавлять величину эффектов “праздников”, что может оказаться полезным при возникновении риска переобучения модели. Такой контроль (регуляризация) осуществляется одним из двух способов:

    глобальный контроль — распространяется на все моделируемые события;
    контроль на уровне отдельных событий.

Аргумент holidays.prior.scale функции prophet() позволяет реализовать первый из этих способов. Данный аргумент задает априорное значение стандартного отклонения (нормального) распределения, с помощью которого моделируется эффект того или иного события. По умолчанию holidays.prior.scale = 10, что соответствует незначительной регуляризации. Уменьшение этого заданного по умолчанию значения приведет к подавлению эффектов всех событий, включенных в модель (рис. 6.14):

# Для глобальной регуляризации эффектов праздников служит аргумент
# holidays.prior.scale:
M8 <- prophet(holidays = key_dates2,
              changepoint.range = 0.9,
              holidays.prior.scale = 0.01)
M8 <- add_country_holidays(M8, country_name = "US")
M8 <- fit.prophet(M8, bitcoin_train)
forecast_M8 <- predict(M8, future_df)

# Эффекты праздников до (модель M7) и после (M8)
# глобальной регуляризации:
m7_holidays <- 
  plot_forecast_component(M7, forecast_M7, name = "holidays") +
  labs(title = "M7") + ylim(c(-0.15, 0.25))
m8_holidays <- 
  plot_forecast_component(M8, forecast_M8, name = "holidays") +
  labs(title = "M8") + ylim(c(-0.15, 0.25))
gridExtra::grid.arrange(m7_holidays, m8_holidays, nrow = 1)

Эффекты событий до (модель M7) и после (модель M8) глобальной регуляризации

РИСУНОК 6.14: Эффекты событий до (модель M7) и после (модель M8) глобальной регуляризации

Для управления эффектами отдельных событий в таблицу с перечнем событий необходимо добавить столбец prior_scale. В качестве примера уменьшим величину эффекта события event_5, оставив остальные уровни без изменений (т.е. используя принятое по умолчанию значение параметра prior_scale = 10):

key_dates3 <- dplyr::bind_cols(key_dates2, 
                               prior_scale = c(10, 10, 10, 10, 0.01))

M9 <- prophet(holidays = key_dates3, changepoint.range = 0.9)

M9 <- add_country_holidays(M9, country_name = 'US')
M9 <- fit.prophet(M9, bitcoin_train)
forecast_M9 <- predict(M9, future_df)

m9_holidays <- 
  plot_forecast_component(M9, forecast_M9, name = "holidays") +
  labs(title = "M9") + ylim(c(-0.15, 0.25))
gridExtra::grid.arrange(m7_holidays, m9_holidays, nrow = 1)

Пример регуляризации эффекта отдельного события

РИСУНОК 6.15: Пример регуляризации эффекта отдельного события

На рис. 6.15 хорошо виден результат подавления эффекта события event_5 (сравните уровень самого большого пика на графике слева с уровнем пика в той же позиции на графике справа). При этом эффекты большинства других событий и официальных праздников остались почти неизменными.
6.6 Сезонные компоненты

Как было отмечено в разд. 6.1, сезонные компоненты аппроксимируются в prophet с помощью частичных сумм ряда Фурье, число членов которого (порядок) определяет гладкость соответствующей функции. Рассмотрим различные способы спецификации сезонных колебаний.
6.6.1 Годовая, недельная и дневная компоненты

Функция prophet() имеет три аргумента, с помощью которых можно контролировать гладкость функций годовой, недельной и дневной сезонности: yearly.seasonality, weekly.seasonality и daily.seasonality (см. разд. 6.3). Увеличение значений этих аргументов приведет к подгонке менее гладких функций соответствующих компонент (что одновременно увеличит риск переобучения модели). На рис. 6.16 для примера показана функция годовой сезонности, оцененная с помощью модели M3 из разд. 6.4 (график этой функции построен с помощью служебной функции plot_yearly(), которую можно вызвать только обычным в таких случаях образом, т.е. указав имя пакета в сочетании с тройным двоеточием перед именем скрытой функции).

prophet:::plot_yearly(M3)

Функция годовой сезонности, оцененная с помощью модели M3

РИСУНОК 6.16: Функция годовой сезонности, оцененная с помощью модели M3

Увеличив значение аргумента yearly.seasonality с заданного по умолчанию 10 до 20, мы получим менее гладкую кривую (рис. 6.17):

M3B <- prophet(bitcoin_train, 
               yearly.seasonality = 20,
               changepoint.range = 0.9, 
               changepoint.prior.scale = 0.02)

prophet:::plot_yearly(M3B)

Функция годовой сезонности, оцененная с помощью модели M3B

РИСУНОК 6.17: Функция годовой сезонности, оцененная с помощью модели M3B
6.6.2 Пользовательские сезонные компоненты

Для данных, охватывающих как минимум два года, функция prophet() автоматически добавит в модель компоненты годовой и недельной сезонности. Если гранулярность данных превышает дневную (например, когда имеются почасовые наблюдения зависимой переменной), то в модель автоматически будет добавлена также и компонента дневной сезонности. Помимо этого, пользователи имеют возможность добавить и любые другие сезонные компоненты с помощью функции add_seasonality() (например, часовую, месячную, квартальную и т.п.). Эта функция имеет следующие аргументы:

    m — модельный объект;
    name — название сезонной компоненты;
    period — число (необязательно целое), соответствующее количеству временных интервалов в одном сезонном цикле;
    fourier.order — порядок (количество членов) ряда Фурье (по умолчанию равен 3 для недельной сезонности и 10 для годовой);
    mode — тип модели; принимает два возможных значения — "additive" (аддитивная; выбирается по умолчанию) и "multiplicative" (мультипликативная);
    condition.name — название сторонней переменной, которая задает разные режимы моделируемой сезонности (см. ниже).

Рассмотрим примеры использования функции add_seasonality() и ее аргументов.

В приведенном ниже коде мы сначала отключаем автоматически добавляемую в модель недельную сезонность и вместо нее добавляем месячную (допустив, что один месячный период составляет 30.5 дней). На рис. 6.18 представлены все сезонные компоненты полученной модели (тренд, годовая сезонность и месячная сезонность).

M10 <- prophet(weekly.seasonality = FALSE)
M10 <- add_seasonality(m = M10,
                       name = "monthly",
                       period = 30.5,
                       fourier.order = 5)
M10 <- fit.prophet(M10, bitcoin_train)
forecast_M10 <- predict(M10, future_df)
prophet_plot_components(M10, forecast_M10)

Компоненты модели M10

РИСУНОК 6.18: Компоненты модели M10

Аналогичным образом вместо компоненты месячных колебаний мы могли бы добавить, например, компоненту квартальной сезонности (задав период длиной 365.25/4 дней):

M11 <- prophet(weekly.seasonality = FALSE)
M11 <- add_seasonality(m = M11,
                       name = "quarter",
                       period = 365.25/4,
                       fourier.order = 2)
M11 <- fit.prophet(M11, bitcoin_train)
forecast_M11 <- predict(M11, future_df)
prophet_plot_components(M11, forecast_M11)

Компоненты модели M11

РИСУНОК 6.19: Компоненты модели M11
6.6.3 Условные режимы сезонности

В ряде случаев функция, аппроксимирующая ту или иную сезонную составляющую, может изменять свои свойства в зависимости от каких–то сторонних факторов. Например, колебания в течение рабочих дней могут иметь характер, сильно отличающийся от такового в выходные дни. Пакет prophet позволяет моделировать такие условные режимы сезонности (т.е. режимы, которые зависят от сторонних факторов) с помощью аргумента condition.name функции add_seasonality(). Как следует из названия, на этот аргумент подается имя (булевой) переменной, которая определяет соответствующий режим. Такие переменные должны хранится в той же таблице, что и основные данные по временному ряду.

Исключительно в качестве примера предположим, что недельные колебания стоимости биткоина в летние месяцы отличаются от таковых в другие месяцы. Чтобы смоделировать такое различие добавим в таблицу с данными bitcoin_train две новые индикаторные переменные: summer (принимает значение TRUE в летние месяцы и FALSE в другие месяцы) и not_summer (TRUE в нелетние месяцы и FALSE летом). Важно помнить, что такие же переменные нужно добавить и в таблицу с будущими датами future_df — иначе прогнозные значения рассчитать не получится:

# Функция для удобного добавления переключателей режимов:
is_summer <- function(ds) {
    month <- as.numeric(format(ds, '%m'))
    return(month > 5 & month < 9)
}

# Добавляем переключатели режима в данные:
bitcoin_train$summer <- is_summer(bitcoin_train$ds)
bitcoin_train$not_summer <- !bitcoin_train$summer
future_df$summer <- is_summer(future_df$ds)
future_df$not_summer <- !future_df$summer

# Подгоняем модель:
M12 <- prophet(weekly.seasonality = FALSE)
M12 <- add_seasonality(M12, name = 'weekly_summer', 
                       period = 7,
                       fourier.order = 3,
                       condition.name = 'summer') 
M12 <- add_seasonality(M12, name = "weekly_not_summer",
                       period = 7, 
                       fourier.order = 3,
                       condition.name = "not_summer")
M12 <- fit.prophet(M12, bitcoin_train)

forecast_M12 <- predict(M12, future_df)
prophet_plot_components(M12, forecast_M12)

Оцененные компоненты модели M12

РИСУНОК 6.20: Оцененные компоненты модели M12

# Удалим переменные `summer` и `not_summer` из таблицы
# `bitcoin_train` - в будущем они нам не понадобятся:
bitcoin_train$summer <- NULL
bitcoin_train$not_summer <- NULL

Согласно полученной модели, в нелетние месяцы стоимость биткоина в течение недели обычно достигает максимума по средам, тогда как в летние месяцы по средам обычно наблюдается противоположная картина (рис. 6.20).
6.6.4 Регуляризация сезонных компонент

Подобно тому, как это было с эффектами праздников и других важных событий (разд. 6.5), мы можем контролировать уровень вклада сезонных компонент. Глобальный контроль выполняется с помощью аргумента seasonality.prior.scale функции prophet() (разд. 6.3). Контроль на уровне отдельных сезонных компонент возможен с помощью аргумента prior.scale функции add_seasonality(). По умолчанию prior.scale = 10. Уменьшение этого значения приведет к подавлению вклада соответствующей компоненты.
6.6.5 Аддитивная и мультипликативная сезонности

Как было отмечено в разд. 1.3, по характеру функциональной связи между своими компонентами модели временных рядов делятся на два основных типа — аддитивные и мультипликативные. Первый из них применяется в случаях, когда амплитуда сезонных колебаний приблизительно постоянна. Если же эта амплитуда заметно изменяется во времени (обычно возрастает), то строят мультипликативную модель.

В пакете prophet по умолчанию подгоняются аддитивные модели временных рядов (разд. 6.1). В мультипликативных моделях, как следует из их названия, сезонная компонента умножается на тренд (в связи с этим вклад сезонных колебаний моделируется в виде доли (%) от уровня тренда):

y(t)=g(t)×s(t)+h(t)+ϵt.

В приведенном уравнении предполагается, что амплитуда всех сезонных компонент существенно изменяется во времени. Для подгонки соответствующих моделей необходимо воспользоваться аргументом seasonality.mode функции prophet() (рис. 6.21):

M14 <- prophet(bitcoin_train, seasonality.mode = "multiplicative")
forecast_M14 <- predict(M14, future_df)
plot(M14, forecast_M14)

Прогноз стоимости биткоина, полученный на основе модели M14

РИСУНОК 6.21: Прогноз стоимости биткоина, полученный на основе модели M14

Однако в пакете prophet имеется возможность и более тонкого контроля над аддитивностью сезонных компонент. Так, например, можно построить модели, в которых недельная колебания представлены в аддитивном виде, а годовые — в мультипликативном. Вероятно, вы уже догадались, что для этого применяется функция add_seasonality():

M15 <- prophet(yearly.seasonality = FALSE)
M15 <- add_seasonality(M15, name = 'yearly', 
                       period = 365.25,
                       fourier.order = 10, 
                       mode = "multiplicative")
M15 <- fit.prophet(M15, bitcoin_train)

forecast_M15 <- predict(M15, future_df)
prophet_plot_components(M15, forecast_M15)

Оцененные компоненты модели M15

РИСУНОК 6.22: Оцененные компоненты модели M15
6.7 Модели с предикторами

Поскольку модели временных рядов, построенные с помощью пакета prophet, представляют собой одну из разновидностей регрессионных моделей (разд. 6.1), то помимо обычных компонент и эффектов “праздников” в такие модели можно добавить и любые другие предикторы. Для этого служит функция add_regressor(), которая имеет следующие аргументы:

    m — модельный объект;
    name — название добавляемого предиктора;
    prior.scale — параметр, используемый для регуляризации эффекта добавляемого предиктора (здесь не рассматривается, однако см., например, разд. 6.5);
    standardize — позволяет стандартизовать значения добавляемого предиктора перед подгонкой модели (по умолчанию принимает значение "auto" — в этом случае предиктор будет стандартизован, если только он не является индикаторной переменной со значениями 1 и 0; другие возможные значения этого аргумента: TRUE и FALSE);
    mode — необязательный параметр, определяющий характер сезонности добавляемого предиктора (по умолчанию равен m$seasonality.mode).

Все предикторы, добавляемые в модель с помощью функции add_regressor(), должны присутствовать в таблице с обучающими данными. Для расчета предсказаний будущие значения каждого предиктора должны присутствовать также в таблице с датами, задающими прогнозный отрезок времени. Последнее обстоятельство делает расчет прогноза с использованием количественных предикторов и многих качественных переменных проблематичным: будущие значения таких предикторов (в отличие, например, от дат официальных праздников и других регулярных событий) обычно исследователю не известны. Как правило, для решения этой проблемы сначала строят отдельные модели временных рядов для каждого предиктора, а затем используют предсказанные с помощью таких моделей будущие значения предикторов для получения искомого прогноза. Конечно, такой подход существенно усложняет весь процесс моделирования (поскольку возникает необходимость построения надежных моделей для отдельных предикторов) и потенциально увеличивает неточность прогноза, однако в большинстве случаев это — лучшее, что можно сделать. Именно такой стратегией мы воспользуемся в описанном ниже примере.

Добавим в модель стоимости биткоина три предиктора: цены на акции компаний Amazon, Google и Facebook, хранящиеся в таблице shares_na_filled (гл. 2). Нужно подчеркнуть, что выбор цен на акции в качестве предикторов, равно как и выбор именно этих компаний, ни с чем не связаны — просто такие данные легко получить из публично доступных источников. Добавим эти данные в таблицу bitcoin_train:

require(tidyr)

# Размах дат в таблицах:
bitcoin_train %>% pull(ds) %>% range()

## [1] "2016-01-01" "2019-05-26"

shares_na_filled %>% pull(ds) %>% range()

## [1] "2016-01-01" "2019-05-26"

# Объединение таблиц (по ключу `ds`):
bitcoin_train <- bitcoin_train %>% 
  left_join(., shares_na_filled, by = "ds") %>%
  mutate(price = log(price)) %>% 
  pivot_wider(., names_from = share, values_from = price)

Обратите внимание: даты в обеих объединенных нами таблицах лежат в пределах от 2016-01-01 до 2019-05-26 (включительно), что соответствует периоду обучающих данных. Важно также понимать, что на момент написания этого раздела (октябрь 2019 г.) интересующий нас прогнозный период (c 2019-05-27 по 2019-08-24) уже стал историей и, соответственно, цены на акции для этого периода были известны. Но, конечно же, мы не можем использовать эти ставшие историей данные для прогнозирования стоимости биткоина на период с 2019-05-27 по 2019-08-24: в реальной ситуации при расчете прогноза подобное “заглядывание в будущее” было бы невозможно.

Следует также отметить, что хотя prophet–модели мало чувствительны к наличию пропущенных значений в зависимой переменной, пропущенные значения в предикторах недопустимы. Поэтому в приведенном выше коде мы добавили в исходные данные таблицу shares_na_filled, в которой пропущенные наблюдения уже были восстановлены (методом LOCF, см. гл. 2).

Как отмечено выше, цены на акции Amazon, Google и Facebook выбраны в качестве предикторов исключительно из удобства. Тем не менее, все три переменные демонстрируют определенную (нелинейную) связь со стоимостью биткоина и, соответственно, вполне подходят для наших целей (рис. 6.23):

bitcoin_train %>% 
  pivot_longer(-c(y, ds), names_to = "share",
               values_to = "price") %>% 
  ggplot(., aes(price, y)) + 
  geom_point(alpha = 0.1) +
  geom_smooth(se = FALSE) +
  facet_wrap(~share, scales = "free_x", ncol = 3) +
  theme_minimal()

Связь между ценой акций трех компаний и стоимостью биткоина

РИСУНОК 6.23: Связь между ценой акций трех компаний и стоимостью биткоина

Однако прежде, чем перейти к построению модели стоимости биткоина, нам необходимо решить проблему с будущими значениями предикторов. Для этого мы построим отдельные модели для каждого предиктора, а затем рассчитаем их предсказанные значения для интересующего нас прогнозного периода:

# Функция, которая поможет нам получить прогнозные значения
# цены акций одновременно для всех трех компаний 
get_price_futures <- function(df) {
  df <- dplyr::select(df, -share) %>% rename(y = price)
  m <- prophet(df,
               n.changepoints = 15, 
               changepoint.range = 0.9,
               weekly.seasonality = FALSE)
  future_df_shares <- future_df %>% dplyr::select(ds)
  price_forecast <- predict(m, future_df_shares)
  
  future_df_shares %>% 
    mutate(price = price_forecast$yhat) %>% return()
}

future_share_price <- bitcoin_train %>% 
  pivot_longer(-c(y, ds), names_to = "share", 
               values_to = "price") %>% 
  dplyr::select(-y) %>% group_by(share) %>% 
  do(get_price_futures(.)) %>% 
  pivot_wider(., names_from = share, values_from = price)
head(future_share_price)

## # A tibble: 6 x 4
##   ds                   amzn    fb  goog
##   <dttm>              <dbl> <dbl> <dbl>
## 1 2016-01-01 00:00:00  6.34  4.55  6.55
## 2 2016-01-02 00:00:00  6.35  4.55  6.55
## 3 2016-01-03 00:00:00  6.35  4.55  6.55
## 4 2016-01-04 00:00:00  6.35  4.55  6.56
## 5 2016-01-05 00:00:00  6.36  4.55  6.56
## 6 2016-01-06 00:00:00  6.36  4.56  6.56

Исходные данные и прогнозные значения цен на акции показаны на рис. 6.24.

future_share_price %>% pivot_longer(-ds, names_to = "share", 
                                    values_to = "price") %>% 
  mutate(period = ifelse(ds > as.Date("2019-05-26"),
                         "future", "history")) %>% 
  ggplot(aes(ds, price, col = period)) +
  geom_line(size = 1) +
  scale_colour_manual(values = c("red", "gray70")) +
  facet_wrap(~share, scales = "free_y", ncol = 3) +
  theme_minimal() + theme(legend.position = "bottom")

Исторические данные по цене акций (серые линии) и предсказанные значения (красные линии)

РИСУНОК 6.24: Исторические данные по цене акций (серые линии) и предсказанные значения (красные линии)

Теперь у нас есть все, чтобы построить модель стоимости биткоина с тремя предикторами и рассчитать прогнозные значения (рис. 6.25):

M16 <- prophet(n.changepoints = 15, changepoint.range = 0.9)
M16 <- add_regressor(M16, 'amzn')
M16 <- add_regressor(M16, 'goog')
M16 <- add_regressor(M16, 'fb')
M16 <- fit.prophet(M16, bitcoin_train)
forecast_M16 <- future_share_price %>% predict(M16, .)
plot(M16, forecast_M16)

Прогноз стоимости биткоина, полученный на основе модели M16

РИСУНОК 6.25: Прогноз стоимости биткоина, полученный на основе модели M16

На рис. 6.26 представлены оцененные компоненты модели M16. Заметьте, что эффекты всех трех предикторов объединены в одну компоненту (см. extra_regressors_additive на графике внизу):

prophet_plot_components(M16, forecast_M16)

Оцененные компоненты модели M16

РИСУНОК 6.26: Оцененные компоненты модели M16

С помощью рассмотренной ранее функции plot_forecast_component() (разд. 6.5) мы можем также изобразить эффекты отдельных предикторов (рис. 6.27):

amzn_comp <- 
  plot_forecast_component(M16, forecast_M16, name = "amzn") +
    ggtitle("Amazon")
fb_comp <- 
  plot_forecast_component(M16, forecast_M16, name = "fb") +
    ggtitle("Facebook")
goog_comp <- 
  plot_forecast_component(M16, forecast_M16, name = "goog") +
    ggtitle("Google")
gridExtra::grid.arrange(amzn_comp, fb_comp, goog_comp, ncol = 3)

Оцененные эффекты предикторов, включенных в модель M16

РИСУНОК 6.27: Оцененные эффекты предикторов, включенных в модель M16

Согласно полученной модели, эффект переменной amzn оказался сильнее (примерный диапазон значений от –0.2 до 0.2), чем эффекты goog (от –0.005 до 0.005) и fb (от –0.06 до 0.06). Мы можем сделать такое заключение благодаря тому, что эффекты всех трех предикторов представлены на одной шкале и поэтому сравнимы (значения всех этих переменных перед подгонкой модели были стандартизованы — см. выше описание аргумента standardize функции add_regressor()). Интересно также, что характер изменения эффекта amzn во времени почти зеркально отличается от такового у переменных goog и fb. Оставим читателям возможность подумать над интерпретацией этого наблюдения самостоятельно.

В рассмотренном нами примере все добавленные в модель независимые переменные были количественными. В случае с качественными предикторами у исследователя есть два варианта на выбор: либо представить значения таких переменных в виде “праздников” (разд. 6.5), либо воспользоваться описанной выше более общей функцией add_regressor(). В обоих случаях качественные переменные необходимо преобразовать в индикаторные (т.е. создать отдельные столбцы для каждого уровня переменной со значениями 1 и 0).
6.8 Выбор оптимальной модели

В предыдущих разделах этой главы мы построили целый ряд моделей для прогнозирования стоимости биткоина. Но какая из этих моделей лучше? Стандартным методом оценки качества нескольких альтернативных моделей является перекрестная проверка. Суть этого метода сводится к тому, что исходные обучающие данные случайным образом разбиваются на K
частей (блоков), после чего модель k раз подгоняется по K−1

блокам, а оставшийся блок каждый раз используется для проверки качества предсказаний на основе той или иной подходящей случаю метрики. Полученная таким образом средняя метрика будет хорошей оценкой качества предсказаний модели на новых данных.

К сожалению, в случае с моделями временных рядов такой способ выполнения перекрестной проверки не имеет смысла и не отвечает стоящей задаче. Поскольку во временных рядах, как правило, имеет место значительная автокорреляция (гл. 4), то мы не можем просто разбить такой ряд случайным образом на K

частей — это приведет к потере указанной корреляции. Более того, в результате случайного разбиения данных на несколько блоков может получиться так, что в какой–то из итераций мы построим модель преимущественно по недавним наблюдениям, а затем оценим ее качество на блоке из давних наблюдений. Другими словами, мы построим модель, которая будет предсказывать прошлое, что не имеет никакого смысла — ведь мы пытаемся решить задачу по предсказанию будущего!

Для решения описанной проблемы при работе с временными рядами применяют несколько модификаций перекрестной проверки (Hyndman and Athanasopoulos 2019; Tashman 2000). В пакете prophet, в частности, реализован т.н. метод “имитированных исторических прогнозов” (Simulated Historical Forecasts, SHF). Рассмотрим, что этот метод собой представляет, и как им пользоваться для выбора оптимальной модели.
6.8.1 Метод имитированных исторических прогнозов

Любая модель временного ряда строится на основе данных, собранных в течение некоторого периода в прошлом. Далее по полученной модели рассчитываются прогнозные значения для интересующего нас промежутка времени (горизонта) в будущем. Такая процедура повторяется каждый раз, когда необходимо сделать новый прогноз (рис. 6.28).
Стандартная процедура построения моделей для прогнозирования временных рядов

РИСУНОК 6.28: Стандартная процедура построения моделей для прогнозирования временных рядов

Метод SHF (рис. 6.29) пытается сымитировать описанную выше процедуру. В пределах отрезка с исходными обучающими данными выбирают K
“точек отсчета” (“cut–off points” по терминологии prophet), на основе которых формируются блоки данных для выполнения перекрестной проверки: все исторические наблюдения, предшествующие k–й точке отсчета (а также сама эта точка), образуют обучающие данные для подгонки соответствующей модели, а H исторических наблюдений, следующих за точкой отсчета, образуют прогнозный горизонт. Расстояние между точками отсчета называется “периодом” (“period”) и по умолчанию составляет H/2. Обучающие наблюдения в первом из K блоков образуют т.н. “initial period” (“начальный отрезок”). В prophet длина этого отрезка по умолчанию составляет 3×H

, однако исследователь при желании может ее изменить.

Каждый раз после подгонки модели на обучающих данных из k

–го блока рассчитываются предсказания для прогнозного горизонта того же блока, что позволяет оценить качество прогноза с помощью подходящей случаю метрики (например, RMSE; см. ниже). Значения этой метрики, усредненные по каждой дате прогнозных горизонтов каждого блока, в итоге дают оценку качества предсказаний, которую можно ожидать от модели, построенной по всем исходным обучающим данным. Это в свою очередь позволяет сравнить несколько альтернативных моделей и выбрать оптимальную.
Процедура, лежащая в основе метода имитированных исторических прогнозов

РИСУНОК 6.29: Процедура, лежащая в основе метода имитированных исторических прогнозов

Таким образом, SHF близок к классическому способу выполнения перекрестной проверки моделей временных рядов по методу “скользящей точки отсчета” (“rolling origin evaluation”; Tashman 2000), однако отличается от последнего тем, что для оценивания качества предсказаний используется меньше блоков и прогнозные горизонты этих блоков удалены друг от друга на некоторое расстояние. С одной стороны, это является преимуществом метода SHF, поскольку он требует меньше вычислений и получаемые оценки качества предсказаний не так сильно коррелируют друг с другом, как в случае с перекрестной проверкой по методу “скользящей точки отсчета”. С другой стороны, при небольшом количестве блоков K

оценка качества модели может оказаться ненадежной. С решением последней проблемы отчасти помогает увеличение отрезка исходных исторических данных (поскольку чем он длиннее, тем больше блоков можно в него вместить). Однако следует помнить, что модели, построенные на длинных временных рядах, часто демонстрируют низкое качество прогнозов, поскольку параметры таких моделей задать труднее и возрастает риск переобучения.
6.8.2 Выполнение перекрестной проверки

В пакете prophet перекрестная проверка по методу имитированных исторических прогнозов выполняется с помощью функции cross_validation(), которая имеет следующие аргументы:

    model — модельный объект;
    horizon — длина прогнозного горизонта в каждом блоке данных, используемом для выполнения перекрестной проверки;
    units — название единицы измерения времени (например, "days", "hours", "secs" — см. справочный файл по базовой функции difftime());
    initial — длина начального отрезка с обучающими данными в первом блоке.

Функция cross_validation() возвращает таблицу c наблюденными (y) и оцененными (yhat) значениями моделируемой переменной, а также доверительными границами предсказанных значений (yhat_lower и yhat_upper) для каждой точки отсчета cutoff и каждой даты ds соответствующего прогнозного периода (в примере используется модель M3 из разд. 6.4):

M3_cv <- cross_validation(M3, initial = 730,
                          period = 90,
                          horizon = 90,
                          units = "days")

head(M3_cv)

##          y         ds     yhat yhat_lower yhat_upper     cutoff
## 1 9.349206 2018-03-03 9.226595   9.113810   9.338773 2018-03-02
## 2 9.351197 2018-03-04 9.212202   9.108078   9.321019 2018-03-02
## 3 9.356456 2018-03-05 9.206319   9.096260   9.311673 2018-03-02
## 4 9.285439 2018-03-06 9.193538   9.085362   9.307952 2018-03-02
## 5 9.206891 2018-03-07 9.181843   9.069791   9.287407 2018-03-02
## 6 9.147934 2018-03-08 9.171255   9.056305   9.283333 2018-03-02

6.8.3 Метрики качества модели

Как следует из ее названия, функция performance_metrics() позволяет рассчитать метрики, характеризующие качество предсказаний моделей. В частности, имеется возможность рассчитать следующие показатели:

    Среднеквадратичная ошибка (mean squared error, MSE):

MSE=1nn∑i=1(yi−^yi)2

    Квадратный корень из среднеквадратичной ошибки (root mean squared error, RMSE):

RMSE=
⎷1nn∑i=1(yi−^yi)2

    Средняя абсолютная ошибка (mean absolute error, MAE):

MAE=n∑i=1|yi−^yi|

    Средняя абсолютная удельная ошибка (mean absolute percentage error, MAPE):

MAPE=n∑i=1|yi−^yiyi|

    “Покрытие” (coverage): доля истинных значений моделируемой переменной, которые находятся в пределах доверительных границ прогноза.

В приведенных формулах yi
и ^yi — это истинное и предсказанное значения моделируемой переменной соответственно, а n

— количество наблюдений.

Функция performance_metrics() имеет следующие аргументы:

    df — таблица, полученная с помощью функции cross_validation();
    metrics — вектор с названиями метрик качества модели (по умолчанию этот аргумент принимает значение NULL, что приводит к расчету всех перечисленных выше метрик, т.е. c("mse", "rmse", "mae", "mape", "coverage"));
    rolling_window — размер “скользящего окна”, в пределах которого происходит усреднение каждой метрики (по умолчанию принимает значение 0.1, т.е. 10% от длины прогнозного горизонта; см. пояснения ниже).

На рис. 6.30 представлено схематичное изображение того, как функция performance_metrics() рассчитывает метрики качества модели в случае с перекрестной проверкой по 5 блокам данных с длиной прогнозного горизонта H=100

и аргументом rolling_window = 0.1.
Процедура расчета метрик качества моделей при выполнении перекрестной проверки по методу SHF

РИСУНОК 6.30: Процедура расчета метрик качества моделей при выполнении перекрестной проверки по методу SHF

В приведенном ниже примере функция performance_metrics() применена для расчета среднеквадратичной ошибки прогноза построенной нами ранее модели M3:

performance_metrics(M3_cv, metrics = "mse",
                    rolling_window = 0.1) %>% head()

##   horizon        mse
## 1  9 days 0.06424673
## 2 10 days 0.07572021
## 3 11 days 0.08695892
## 4 12 days 0.09707747
## 5 13 days 0.10990773
## 6 14 days 0.12260315

Как видно из полученного результата, первое усредненное значение MSE приходится на 9–й день прогнозного горизонта, поскольку длина этого горизонта для модели M3 составляет 90 дней (см. выше код для создания таблицы M3_cv), а 9 — это 10% от этой длины (размер скользящего окна, задаваемый аргументом rolling_window).

Если аргументу rolling_window присвоить значение 0, то запрашиваемые метрики качества будут рассчитаны для каждой даты прогнозного горизонта (т.е. размер скользящего окна в данном случае фактически равен 1):

performance_metrics(M3_cv, metrics = "mse",
                    rolling_window = 0) %>% head()

##   horizon        mse
## 1  1 days 0.03595728
## 2  2 days 0.03941046
## 3  3 days 0.05343681
## 4  4 days 0.05035319
## 5  5 days 0.05454100
## 6  6 days 0.07256616

Если же аргументу rolling_window присвоить значение 1, то запрашиваемые метрики качества будут усреднены по всему прогнозному горизонту:

performance_metrics(M3_cv, metrics = "mse",
                    rolling_window = 1) %>% head()

##   horizon      mse
## 1 90 days 0.192834

Метрики качества моделей, полученные в ходе перекрестной проверки, можно визуализировать с помощью функции plot_cross_validation_metric(), которая имеет следующие аргументы:

    df_cv — таблица, полученная с помощью функции cross_validation();
    metric — название метрики;
    rolling_window — размер “скользящего окна”, в пределах которого происходит усреднение метрики (см. рис. 6.30 и описание функции performance_metrics()).

Функция plot_cross_validation_metric() возвращает объект класса ggplot:

plot_cross_validation_metric(M3_cv, metric = "mse",
                             rolling_window = 0.1)

Визуализация метрики качества предсказаний (MSE), полученной по результатам перекрестной проверки модели M3

РИСУНОК 6.31: Визуализация метрики качества предсказаний (MSE), полученной по результатам перекрестной проверки модели M3

На рис. 6.31 приведены оценки MSE для каждой из дат прогнозного горизонта (H=90
) каждого из K=5

блоков данных, участвовавших в перекрестной проверке. Голубая линия соответствует усредненным значениям в пределах каждого скользящего окна размером в 9 наблюдений. Судя по большому разбросу полученных оценок MSE, качество модели M3 желает оставлять лучшего.
6.8.4 Пример выбора оптимальной модели

Рассмотрим теперь, как описанную выше методологию выполнения перекрестной проверки можно применить для выбора оптимальной модели из нескольких альтернативных. Предположим, что перед нами стоит задача выбрать оптимальную модель стоимости биткоина из построенных ранее моделей M4, M5 и M12. Для описания качества этих моделей воспользуемся двумя метриками: MAPE и покрытие (подразд. 6.8.3). Для упрощения примера предположим также, что нас интересует качество предсказаний в целом для 90–дневного прогнозного горизонта (т.е. нам неинтересны отдельные даты этого горизонта). Рассчитаем обе метрики качества для каждой из моделей–кандидатов:

M4_cv <- cross_validation(M4, initial = 730,
                          period = 180, 
                          horizon = 90,
                          units = "days")
M5_cv <- cross_validation(M5, initial = 730,
                          period = 180,
                          horizon = 90,
                          units = "days")
M12_cv <- cross_validation(M12, initial = 730,
                           period = 180,
                           horizon = 90,
                           units = "days")
M4_perf <- performance_metrics(M4_cv,
                               metrics = c("mape", "coverage"),
                               rolling_window = 1)
M5_perf <- performance_metrics(M5_cv,
                               metrics = c("mape", "coverage"),
                               rolling_window = 1)
M12_perf <- performance_metrics(M12_cv,
                                metrics = c("mape", "coverage"),
                                rolling_window = 1)
M4_perf

##   horizon       mape  coverage
## 1 90 days 0.03214045 0.2851852

M5_perf

##   horizon       mape coverage
## 1 90 days 0.03717749 0.462963

M12_perf

##   horizon       mape coverage
## 1 90 days 0.02347762 0.637037

Как видим, M12 лучше других моделей по обеим выбранным метрикам качества. Это можно видеть также из графиков, построенных с помощью функции plot_cross_validation_metric() (рис. 6.32):

M4_cv_plot <- plot_cross_validation_metric(M4_cv,
                                           metric = "mape",
                                           rolling_window = 0.1) +
  ylim(c(0, 0.15)) + ggtitle("M4")

M5_cv_plot <- plot_cross_validation_metric(M5_cv,
                                           metric = "mape",
                                           rolling_window = 0.1) +
  ylim(c(0, 0.15)) + ggtitle("M5")

M12_cv_plot <- plot_cross_validation_metric(M12_cv,
                                            metric = "mape",
                                            rolling_window = 0.1) +
  ylim(c(0, 0.15)) + ggtitle("M12")

gridExtra::grid.arrange(M4_cv_plot, M5_cv_plot, M12_cv_plot, ncol = 3)

Сравнение качества предсказаний трех моделей по метрике MAPE

РИСУНОК 6.32: Сравнение качества предсказаний трех моделей по метрике MAPE

Вспомним, что до сих пор мы строили все модели по обучающим данным из таблицы bitcoin_train. Однако у нас есть и проверочный набор данных — bitcoin_test (см. разд. 6.2). Посмотрим, как выбранная нами оптимальная модель M12 сработает на этой проверочной выборке. На рис. 6.33 представлены обучающие данные (черные точки; для удобства показаны наблюдения только за 2019 г.) и истинные значения стоимости биткоина в прогнозном периоде (красные точки). Голубая сплошная линия на этом графике соответствует предсказанным моделью значениям, а светло–голубая полоса вокруг нее — 80%–ной доверительной области предсказанных значений:

plot(M12, forecast_M12) + 
    coord_cartesian(xlim = c(as.POSIXct("2019-01-01"),
                             as.POSIXct("2019-08-24"))) +
    geom_point(data = bitcoin_test, 
               aes(as.POSIXct(ds), y), col = "red")

Сравнение истинных значений стоимости биткоина и прогнозных значений, полученных с помощью модели M12. См. пояснения в тексте

РИСУНОК 6.33: Сравнение истинных значений стоимости биткоина и прогнозных значений, полученных с помощью модели M12. См. пояснения в тексте

Хотя выбранная нами в качестве оптимальной модель M12 не смогла правильно предсказать некоторые локальные колебания стоимости биткоина в прогнозном периоде, в целом она дала неплохой результат: большинство истинных значений стоимости оказалось в пределах 80%–ной доверительной полосы. Однако следует подчеркнуть, что это всего лишь пример использования перекрестной проверки для сравнения качества предсказаний нескольких моделей: совершенно точно не стоит разрабатывать стратегию торговли биткоином на основе приведенных здесь результатов!
6.9 Моделирование емкости системы

Во всех примерах из предыдущих разделов этой главы предполагалось, что моделируемая переменная может расти во времени бесконечно. Однако многие системы имеют естественную “емкость”, выше которой рост невозможен. Классическим примером здесь будет численность популяции какого–либо биологического вида, которая ограничена имеющимися в среде обитания ресурсами. Другой пример — количество пользователей какой–либо онлайн–услуги, которое ограничено доступом в Интернет. Важно отметить, что емкость системы может иметь ограничения и по нижнему порогу (например, численность населения не может быть отрицательной). Одной из особенностей пакета prophet является возможность моделировать временные ряды для подобных систем. Рассмотрим, как это происходит.
6.9.1 Тренд с насыщением

Стандартным подходом для описания роста в системе с ограниченной емкостью является использование логистической функции следующего вида: g(t)=C1+exp(−k(t−m)),
где C — это верхний порог (емкость системы), k — скорость роста, t — время, а m

— параметр, позволяющий “сдвигать” функцию вдоль оси времени. На рис. 6.34 показаны примеры логистической функции с разными значениями параметров.

logistic_growth <- function(x) {C / (1 + exp(-k*(x - m)))}

par(mfrow = c(1, 3))

# Пример 1:
C <- 10
k <- 0.1
m <- 0
curve(logistic_growth(x), from = -100, to = 100)
abline(v = 0, col = "red", lty = 2)
abline(h = 10, col = "blue", lty = 2)
title("C=10, k=0.1, m=0")

# Пример 2:
C <- 10
k <- 0.1
m <- 20
curve(logistic_growth(x), from = -100, to = 100)
abline(v = 20, col = "red", lty = 2)
abline(h = 10, col = "blue", lty = 2)
title("C=10, k=0.1, m=10")

# Пример 3:
C <- 8
k <- 0.05
m <- 0
curve(logistic_growth(x), from = -100, to = 100, ylim = c(0, 10))
abline(v = 0, col = "red", lty = 2)
abline(h = 8, col = "blue", lty = 2)
title("C=8, k=0.05, m=0")

Примеры логистической функции с разными значениями параметров

РИСУНОК 6.34: Примеры логистической функции с разными значениями параметров

Есть два важных аспекта, которые не отражены в приведенном выше уравнении логистической функции (Taylor and Letham 2017). Во–первых, емкость многих систем непостоянна. Например, число людей, имеющих доступ в Интернет (равно как и количество потенциальных пользователей того или иного онлайн–ресурса) со временем возрастает. Поэтому в пакете prophet постоянная емкость системы C
заменена на динамическую C(t)

.

Во–вторых, непостоянной обычно бывает и скорость роста k
. Например, выход новой версии продукта может значительно ускорить рост числа его потребителей. В prophet для моделирования такого рода изменений вводится понятие точек излома тренда (разд. 6.4). Предположим, что S таких точек приходятся на временные отметки sj, j=1,2,…,S. Совокупность всех изменений скорости роста δj можно представить в виде вектора δ∈RS. Тогда скорость роста в любой точке времени t будет равна сумме базовой скорости k и всех изменений, предшествовавших этой точке: k+∑j:t>sjδj. Более наглядно это можно представить с помощью такого вектора a(t)∈{0,1}S, что aj(t)={1,еслиt≥sj0в остальных случаях Тогда скорость роста в момент времени t составит k+a(t)⊺δ. При изменении скорости роста необходимо также изменить параметр сдвига m (см. уравнение выше), чтобы обеспечить гладкий стык сегментов кривой тренда на соответствующей временной отметке. Такая поправка рассчитывается следующим образом: γj=⎛⎝sj−m−∑l<jγl⎞⎠(1−k+∑l<jδlk+∑l≤jδl). В результате кусочная логистическая функция (piecewise logistic growth model), которая используется в пакете prophet для моделирования тренда с насыщением (saturating growth), принимает вид g(t)=C(t)1+exp(−(k+a(t)⊺δ)(t−(m+a(t)⊺γ))). Важным параметром в приведенном уравнении является C(t)

— емкость системы в каждый момент времени. Как задать этот параметр для подгонки модели? Часто у исследователя уже будет хорошее представление о емкости моделируемой системы (например, компании обычно хорошо знают размер рынка, на котором они работают). Если же такого понимания нет, то придется потратить некоторое время на поиск дополнительной информации из сторонних источников (например, прогнозы роста численности населения от Всемирного Банка, тренды в Google–запросах и т.п.).

При неограниченном росте моделируемой системы вместо представленной выше логистической функции в пакете prophet используется кусочно–линейная функция следующего вида (обозначения те же): g(t)=(k+a(t)⊺δ)t+(m+a(t)⊺γ).

Именно такого рода рост по умолчанию предполагался во всех моделях, которые мы рассматривали в предыдущих разделах этой главы.
6.9.2 Примеры моделей с насыщением тренда

Для начала построим модель, в которой рост зависимой переменной ограничен по некоторому верхнему порогу. Для этого воспользуемся данными по стоимости биткоина за период с января 2016 г. по середину декабря 2017 г., когда наблюдался практически экспоненциальный рост этой переменной (см. рис. 1.3). Предположим, что несмотря на свой экспоненциальный характер роста стоимость биткоина в будущем не могла превысить 11.5 (на логарифмической шкале, что соответствует почти 99000$ (!) на исходной шкале). Для введения этого верхнего порога в модель необходимо добавить новый столбец с (обязательным) именем cap в таблицу с обучающими данными:

bitcoin_train_cap <- bitcoin_train %>% 
  filter(ds <= as.Date("2017-12-15")) %>% 
  mutate(cap = 11.5)

Теперь построим модель по этим обучающим данным (обратите внимание использование аргумента growth = "logistic" при вызове функции prophet()), рассчитаем прогноз на следующие 180 дней и изобразим полученный результат (рис. 6.35):

M17 <- prophet(bitcoin_train_cap, growth = "logistic",
               changepoint.range = 0.95,
               changepoint.prior.scale = 0.15)

# Таблица с датами прогнозного периода (180 дней):
future_df_cap <- make_future_dataframe(M17, periods = 180) %>% 
    mutate(cap = 11.5)

forecast_M17 <- predict(M17, future_df_cap)
plot(M17, forecast_M17)

Пример модели с верхним порогом тренда

РИСУНОК 6.35: Пример модели с верхним порогом тренда

Как видим, несмотря на экспоненциальный рост в историческом периоде, предсказанные значения стоимости биткоина постепенно выходят на плато, что обусловлено введенным в модель ограничением на рост.

Многие естественные системы имеют ограничения емкости не только по верхнему, но и нижнему порогу (подобно упомянутой выше численности населения). В prophet имеется возможность учесть это обстоятельство путем добавления еще одного столбца — floor — в таблицы с обучающими данными и данными для расчета прогноза (верхний порог при этом также должен присутствовать в обеих таблицах). Для демонстрации этой возможности воспользуемся данными по стоимости биткоина в 2018 г., когда наблюдался выраженный тренд на ее снижение, и построим модель с верхним ограничением тренда cap = 10 и нижним ограничением floor = 7 (рис. 6.36):

bitcoin_train_cap_floor <- bitcoin_train %>% 
  filter(ds >= as.Date("2018-01-01") & ds <= as.Date("2018-12-31")) %>% 
  mutate(cap = 10, floor = 7)

M18 <- prophet(bitcoin_train_cap_floor, growth = "logistic",
               changepoint.range = 0.85,
               changepoint.prior.scale = 0.15)

future_df_both <- make_future_dataframe(M18, periods = 180) %>% 
  mutate(floor = 7, cap = 10)

forecast_M18 <- predict(M18, future_df_both)
plot(M18, forecast_M18)

Пример модели с нижним порогом тренда

РИСУНОК 6.36: Пример модели с нижним порогом тренда

В рассмотренных выше примерах предполагалось, что и верхний, и нижний пороги емкости системы постоянны. Если в моделируемой вами системе это не так, то в таблицы с данными для соответствующих дат просто необходимо внести подходящие значения cap и/или floor.

\emph{Временным рядом} (рядом динамики, динамическим рядом) называется последовательность значений показателя или признака, зависящего от времени и упорядоченная в хронологическом порядке. 
Отдельные наблюдения временного ряда называются \emph{уровнями} этого ряда.

Уровни ряда могут принимать \emph{детерминированные} или \emph{случайные} значения. 
Примером ряда с детерминированными значениями уровней служит ряд последовательных данных о количестве дней в месяцах. 

Для нас больший интерес представляют ряды со случайными значениями уровней. 

В силу дискретности отчетов мы можем воспринимать временной ряд как конечную выборку из последовательности случайных величин $X_t$ при $t$ из промежутка от~$1$ до~$T$.

При этом, совокупность случайных величин $\{X_t : t \in \mathbb{Z}\}$ мы будем называть \emph{дискретным случайным или стохастическим процессом с дискретным временем}. 

Отметим, что при каждом фиксированном $t$ значение стохастического процесса рассматривается как случайная величина. 
В то же время стохастический процесс «для каждого случая» является некоторой функцией времени, что позволяет рассматривать процесс как случайную функцию времени $X(t)$. 
Эти два подхода позволяют рассматривать стохастический процесс как функцию
двух разнородных величин, случая и момента времени: $X_t = X(\omega ,t)$. 

При фиксированном случае $\omega$ у нас есть некоторая последовательность значений $X_1, X_2,\ldots$, которую мы будем называть \emph{реализацией случайного процесса}. 


Итак, наблюдаемый временной ряд можно воспринимать как реализацию стохастического процесса. В этом случае говорят, что временной ряд $X_t$ порождается стохастическим процессом. 

Отметим характерные отличия временного ряда от пространственных выборок:
\begin{itemize}
    \item уровни временного ряда не являются одинаково распределенными;
    \item уровни временного ряда, как правило, статистически зависимы.
\end{itemize}

\subsection{Некоторые виды временных рядов}
В зависимости от характера временного параметра ряды делятся на моментные и интервальные.

\emph{Моментные ВР:} уровни характеризуют значения показателя по состоянию  на определенные моменты времени. Например, моментными являются временные ряды цен на определенные виды товаров, ряды курсов акций, уровни которых фиксируются для конкретных чисел, ряды численности  населения или стоимости основных фондов, т.к. значения уровней этих рядов определяются ежегодно на одно и то же число.
    
\emph{Интервальные ВР} уровни характеризуют значение показателя за определенные
    периоды времени. Примерами могут служить ряды годовой (месячной, квартальной) динамики производства продукции в натуральном или стоимостном выражении.

Важной особенностью интервальных рядов динамики абсолютных величин является возможность суммирования их уровней.  В результате получаются накопленные временные ряды, имеющие осмысленное содержание и лишенные проблемы повторного счета.  

Суммирование уровней моментного ВР чаще всего бессмысленно. Например, суммируя почасовой временной ряд почасовые объемы выручки в течение суток получмаем посуточный временной ряд, но просуммировав число посетителей кафе в 18:00 за неделю мы не сможем получить какой-то осмысленной информации.

Отметим, что если уровни ряда представляют собой величины полученные из наблюдаемых данных некоторыми преобразованиями, то такие ряды называются \emph{производными}. 




В зависимости от свойств параметра времени временной ряд может быть \emph{регулярным} или \emph{нерегулярным}, в зависимости от того, связан ли с временным рядом календарь.

\emph{Нерегулярный} временной ряд формирует источник, поставляющий данные в произвольные моменты времени, например, суммы средств, снятых через банковский банкомат образуют нерегулярный временной ряд. Нерегулярный временной ряд может иметь длительные периоды без данных или короткие периоды с пакетами данных.


\emph{Регулярный} временной ряд порождает источник, поставляющий данные через равные промежутки времени. Например, ежедневные сводки данных фондового рынка образуют регулярные временные ряды.
Длина промежутка между соседними значениями регулярного временного ряда называется \emph{дискретностью} временного ряда.

Если дискретность ряда велика, можно упустить существенные закономерности в динамике показателя. Например, по квартальным данным невозможно судить о месячных сезонных колебаниях. 
Слишком малая дискретность ряда приводит к увеличению влияния случайностей, маскирующих . 

Вопрос о выборе дискретности временного ряда должен решаться, исходя из целей каждого конкретного исследования.

\subsection{Общая математическая модель временного ряда}

Поскольку случайный дискретный процесс $X(\omega,t)$ представляет собой совокупность случайных величин, то его статистической характеристикой является совместная функция распределения случайных величин.
 
При рассмотрении временного ряда число случайных величин велико и может быть бесконечным. Поэтому, чтобы задать все вероятностные свойства этой конструкции, нам нужна совокупность функций распределения, а именно одномерная функция распределения,
двумерная функция распределения и так далее: 
$$
F_1 \left(x_{t_1}\right); F_2 \left(x_{t_1}, x_{t_2}\right); F_3 \left(x_{t_1}, x_{t_2}, x_{t_3}\right);\ldots
$$

Индексы величин $x_{t_1}, x_{t_2}$ означают, что случайные величины рассматривается в моменты времени  $t_1, t_2$ и так далее, и у них есть совместная функция распределения. 

При этом в другие моменты времени функция распределения будет другая. 

Такая совокупность функций распределения полностью характеризует случайный процесс. 

Эта совокупность функций согласована между собой в следующем смысле. Каждую функцию распределения размерности $n$ можно получить из функции распределения размерности $n+1$. 
Для этого надо проинтегрировать функцию большей размерности по всем значениям
одной из переменной.

На практике, как правило, имеется один единственный отрезок реализации стохастического процесса~--- временной ряд, поэтому говорить об оценивании совокупности всех функций распределения не приходится. 
Кроме того, интуитивно понятно, что если основные статистические характеристики со временем меняются, то мы по короткому кусочку наших наблюдений вообще ничего не сможем сказать о нем. 

Поэтому на стохастические процессы, порождающие исследуемые временные ряды накладывают дополнительные ограничения. 

Например, можно предположить, что функция распределения (или плотность распределения) стохастического процесса является композицией детерминированных функций и белого шума.

Другим подходом является рассмотрение стационарных стохастических процессов. 

\section{Смыкание временного ряда}

\section{Декомпозиция временного ряда}

В практике исследования динамики экономических процессов принято считать, что
значения уровней временных рядов показателей могут содержать следующие
компоненты:
\begin{itemize}
    \item \emph{тренд}~--- компоненту, характеризующую действие  долговременных факторов;
    \item \emph{сезонную компоненту};
    \item \emph{циклическую компоненту};
    \item случайную компоненту~--- \emph{шум}
\end{itemize}

Под \emph{трендом} понимают изменение, определяющее общее направление развития процесса,
основную тенденцию временного ряда. Часто, но не обязательно, от функции тренда требуют наличие свойства монотонности.

Наряду с долговременными тенденциями во временных рядах имеют место регулярные колебания с~более или менее постоянным периодом~--- периодические составляющие, называемые сезонностью.
Обычно, но не обязательно, сезонными называют колебания, период которых  не превышает одного года. Обычно причиной их возникновения считаются природно-климатические условия. 
Иногда причины колебаний имеют социальный характер, например, увеличение закупок в предпраздничный период, увеличение платежей в конце квартала и т.д. 

В случае, если период колебаний является переменным, то их относят к циклической составляющей. Примерами могут служить демографические, инвестиционные и
другие циклы.

Если из временного ряда удалить тренд и периодические и циклические составляющие, то останется нерегулярная компонента, которая формируется в результате действия большого числа случайных факторов. При этом влияние каждого из факторов незначительно.


Разложение временного ряда на компоненты называется декомпозицией временного ряда. 


Выделяют следующие виды декомпозиции:
\begin{itemize}
    \item \emph{аддитивную}: $y_t = u_t+s_t+v_t+\varepsilon_t$
    \item \emph{мультипликативную}: $y_t = u_t\cdot s_t \cdot v_t \cdot \varepsilon_t$
    \item \emph{смешанную} $y_t = u_t\cdot s_t \cdot v_t + \varepsilon_t$
\end{itemize}
где 
$y_t$~--- уровни временного ряда; 
$u_t$~--- трендовая составляющая; 
$s_t$~--- сезонная компонента;
$v_t$~--- циклическая компонента;

Все компоненты временного ряда взаимосвязаны между собой, поэтому разделение временных рядов на компоненты~--- это теоретическая абстракция, так как данное разделение является чисто математической процедурой и осуществляется на базе статистических методов. 
Но, несмотря на условность такого расчленения фактических уровней рядов, такой прием может
оказаться довольно полезным для решения разных проблем анализа и прогнозирования временных рядов.

\subsection{Определение связи между компонентами}
Тип связи между компонентами временного ряда можно определить по нормальному распределению отклонений значений уровней наблюдаемого временного ряда от теоретических, полученных по уравнению тренда. 



\subsection{Методы декомпозиции в Python}



\section{Анализ тренда}

Не существует "автоматического" способа обнаружения тренда временного ряда. 
Однако если тренд является монотонным, то анализировать такой ряд обычно нетрудно. 

Рассмотрим некоторые способы выделения тренда:
\begin{itemize}
    \item полиномиальный, в частности линейный, тренд можно выделить путем построения уравнения регрессии;
    \item сглаживание значений временного ряда;
    \item фильтрация верхних частот (и средних тоже): разложение Фурье, EMD - декомпозиция, 
    \item 
\end{itemize}





\section{Методы сглаживания временных рядов}
Сглаживание всегда включает некоторый способ локального усреднения данных, при котором шумовые компоненты компенсируют друг друга. 
Рассмотрим несколько видов сглаживания:

\subsection{Сглаживание скользящим средним}
Метод сглаживания \emph{скользящим средним}, заключается в том, что каждый член ряда заменяется простым или взвешенным средним $n$~соседних членов, где $n$ - ширина "окна". 
Обычно окно выбирают симметричным относительно вычисляемого элемента, а $n$~--- нечетным, так, чтобы слева и справа от сглаживаемого члена было поровну значений. 
% (см. Бокс и Дженкинс, 1976; Velleman and Hoaglin, 1981). 

Вместо среднего можно использовать медиану значений, попавших в окно. 
Основное преимущество медианного сглаживания, в сравнении со сглаживанием скользящим средним, состоит в том, что результаты становятся более устойчивыми к выбросам (имеющимся внутри окна). 

Однако скользящее медианное сглаживание формирует менее <<гладкую>> кривую, нежели сглаживание скользящим средним и не позволяет использовать веса.

В Python сглаживание скользящим средним может быть реализовано методом 
\par{\centering \href{https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.rolling.html#pandas.DataFrame.rolling}{pandas.DataFrame.rolling}\par}\noindent класса DataFrame пакета Pandas. Этот метод позволяет вычислить как скользящее среднее, так и скользящую медиану.


\subsection{Простое экспоненциальное сглаживание}
Помимо метода скользящей средней удобным способом фильтрации временного ряда 
является экспоненциальное сглаживание, в основе которого лежит следующая рекуррентная формула:
$$
  \hat{y}_t = \alpha y_t + (1-\alpha) \hat{y}_{t-1}
$$
где, $y_t$~--- значение $t$-го уровня наблюдаемого ряда, а $\hat{y}_t$~--- значение $t$-го уровня сглаженного ряда.
Параметр сглаживания $\alpha$~--- характеризует вес текущего наблюдения, $0 < a < 1$,
Чем ближе $\alpha$ к единице, тем менее ощутимо расхождение между сглаженным рядом и исходным. И наоборот, чем ближе~$\alpha$ к~0, тем в большей степени подавляются
случайные колебания ряда и отчетливее вырисовывается его тренд.

В качестве начального значения $\hat{y}_0$ берется 0, первое значение временного ряда или среднее значение нескольких первых уровней временного ряда (пяти или шести наблюдений).


Отметим, что ряд экспоненциальных средних имеет то же математическое ожидание, что и исходный временной ряд, но меньшую дисперсию:
$$
    \sigma^2_{\hat{y}} = \frac{\alpha}{2-\alpha}\sigma^2_{y}
$$ 

Экспоненциальное сглаживание можно использовать как инструмент прогнозирования временного ряда с горизонтом 1.
Для этого рекуррентная формула может быть переписана в следующем виде:
$$
  \hat{y}_{t+1} = \alpha y_t + (1-\alpha) \hat{y}_{t}
$$

Чтобы спрогнозированные величины были стабильны необходимо выбирать малое значение $\alpha$. Большее значение $\alpha$ имеет смысл в том случае, если нужна быстрая реакция на изменения в наблюдениях.

Для оценки оптимального значения $\alpha$ можно минимизировать среднеквадратическую ошибку:
$$
MSE = \frac{1}{n} \sum_{t=1}^n (y_t- \hat{y}_t)^2 \to \min
$$

Следует отметить, методика прогнозирования с помощью экспоненциального сглаживания предполагает отсутствие тренда. Когда же в данных присутствует значительный тренд, простое экспоненциальное сглаживание постоянно отстает от реальных наблюдений, поэтому тренд должен быть устранен или должны быть использованы другие методы сглаживания



Следует отметить, что в методике экспоненциального сглаживания предполагается, что данные колеблются около уровня, который меняется нечасто. Когда же в данных присутствует значительный тренд, простое экспоненциальное сглаживание постоянно отстает от реальных наблюдений. Тогда необходимо использовать другие методы сглаживания, представленные ниже.

В Python простое экспоненциальное сглаживание реализовано:
\begin{itemize}
\item Класс \href{https://www.statsmodels.org/stable/generated/statsmodels.tsa.holtwinters.SimpleExpSmoothing.html}{statsmodels.tsa.holtwinters.SimpleExpSmoothing} пакета statsmodels.
\item Метод \href{https://pandas.pydata.org/pandas-docs/stable/reference/api/pandas.DataFrame.ewm.html}{pandas.DataFrame.ewm} класса DataFrame пакета Pandas.
\end{itemize}

\subsection{Двойное экспоненциальное сглаживание Хольта}

В случае наличия тренда в исходных данных необходима функция прогнозирования линейного тренда. В 1957 году Хольт разработал метод экспоненциального сглаживания, получивший название \emph{двухпараметрического метода Хольта}.
В этом методе учитывается локальный линейный тренд, присутствующий во временных рядах.

Если во временных рядах имеется тенденция к росту, то вместе с оценкой текущего уровня необходима и оценка тренда. 
В методике Хольта значения уровня $L_t$ (level) и тренда $T_t$ (trend) сглаживаются непосредственно, при этом используются различные параметры сглаживания для каждого из них:
$\alpha$~--- для уровня, $\beta$ для тренда. 
% Преимуществом методики Хольта является возможность выбора соотношения, в котором отслеживаются уровень и тренд.

Метод Хольта составляют три рекуррентных уравнения:
$$
\left\lbrace\begin{aligned}
    \hat{y}_{t+m} &= L_{i} + mT_i,\\
    L_t &= \alpha y_t + (1-\alpha) (L_{t-1} + T_{t-1}),\\
    T_t &= \beta(L_t - L_{t-1}) + (1-\beta) T_{t-1},\\
\end{aligned}\right.
\qquad
\alpha,\beta \in [0,1]
$$
где $y_t$~--- наблюдаемый уровень ВР в момент времени $t$, $\hat{y}_t$~--- уровень сглаженного ВР в момент времени $t$; $T_t$~--- значение тренда в момент~$t$; $L_t$~--- экспоненциально сглаженного ряда (оценка текущего уровня) в момент времени~$t$;  $m$~--- горизонт прогнозирования; параметры $\alpha$ и $\beta$ лежат в промежутке от~0 до~1.

Начальные значения обычно берутся следующим образом:$L_1 = y_1$, $T_1 =0$. Иногда, в качестве начального используется среднее значение первых пяти или шести наблюдений.

Как и при обычном экспоненциальном сглаживании, постоянные $\alpha$ и $\beta$ выбираются субъективно или путем минимизации ошибки прогнозирования. 
Чем большие значения весов будут взяты, тем более быстрый отклик на происходящие изменения будет иметь место и наоборот, с уменьшением весов реакция модели на изменения в данных будет более слабой.

Выбор параметров можно осуществлять минимизацией MSE по сетке или градиентным спуском 

Отиметим, что случай $\alpha=\beta$ носит название \emph{двойного экспоненциальным сглаживания Брауна}.

В Python метод двойного экспоненциального сглаживания Хольта реализован в классе
\par{\centering \href{https://www.statsmodels.org/stable/generated/statsmodels.tsa.holtwinters.Holt.html#statsmodels.tsa.holtwinters.Holt}{statsmodels.tsa.holtwinters.Holt}\par}


\section{Алгоритм прогнозирования сезонного ряда на основе метода Хольта"---~Винтерса}
Если в структуре данных присутствуют сезонные колебания, то для уменьшения ошибок прогнозирования применяют трехпараметрическую модель экспоненциального сглаживания, предложенную в 1960 году Винтерсом. Этот подход является расширением метода Хольта с помощью дополнительного уравнения учета сезонных колебаний.
Таким образом, метод Хольта"---~Винтерса учитывает:
\begin{itemize}
\item сглаженный экспоненциальный ряд $L_i$ (level);
\item тренд $T_i$ (trend);
\item сезонность $S_i$ c периодом $s$ (seasonal).
\end{itemize}

В аддитивной форме метод Хольта"---~Винтерса задается уравнениями:
$$
\left\lbrace\begin{aligned}
    \hat{y}_{t+m} &= L_t + mT_t + S_{i-s+1+ ((m-1) \bmod s)}\\
    L_t &= \alpha(y_t - S_{t-s}) + (1-\alpha) (L_{t-1} + T_{t-1}),\\
    T_t &= \beta(L_t - L_{t-1}) + (1-\beta) T_{t-1},\\
    S_t &= \gamma(y_t - L_t) + (1-\gamma) S_{t-s},\\
\end{aligned}\right.
\qquad
\alpha,\beta,\gamma \in [0,1]
$$

В смешанной форме (с мультипликативной сезонностью)  метод Хольта"---~Винтерса имеет вид:
$$
\left\lbrace\begin{aligned}
    \hat{y}_{t+m} &= (L_t + mT_t)S_{i-s+1+ ((m-1) \bmod s)}\\
    L_t &= \alpha \frac{y_t}{S_{t-s}} + (1-\alpha) (L_{t-1} - T_{t-1}),\\
    T_t &= \beta(L_t - L_{t-1}) + (1-\beta) T_{t-1},\\
    S_t &= \gamma \frac{y_t}{L_t} + (1-\gamma) S_{t-s},\\
\end{aligned}\right.
\qquad
\alpha,\beta,\gamma \in [0,1]
$$
где $y_t$~--- наблюдаемый уровень ВР в момент времени $t$, $\hat{y}_t$~--- уровень сглаженного ВР в момент времени $t$; $T_t$~--- значение тренда в момент~$t$; $S_t$~--- значение сезонной компоненты в момент $t$; $L_t$~--- значение экспоненциально сглаженного ряда (оценка текущего уровня) в момент времени~$t$; $s$~--- длина периода сезонной компоненты; $m$~--- горизонт прогнозирования; параметры $\alpha, \beta, \gamma$ лежат в промежутке от~0 до~1.

Метод Винтерса позволяет наиболее просто учесть в модели сезонность, если исходные данные имеют сезонную структуру. Алтернативой может стать исключение сезонной компоненты либо ее учет в самих данных, например, рассмотрением ряда разностей.

В Python метод Хольта"--~Винтерса реализован в классе
\par{\centering \href{https://www.statsmodels.org/stable/generated/statsmodels.tsa.holtwinters.ExponentialSmoothing.html}{statsmodels.tsa.holtwinters.ExponentialSmoothing}\par}

Эта реализация позволяет моделировать декомпозицию  полагая сезонность и тренд как мультипликативным, так и аддитивным.


\end{document}


\subsection{Анализ сезонной компоненты}
В общем, периодическая (сезонная) зависимость может быть формально определена как корреляционная  зависимость порядка~$k$ между каждым $i$-м элементом ряда и $(i-k)$-м элементом (Kendall, 1976). 
Ее можно измерить с помощью автокорреляции (т.е. корреляции между самими членами ряда); 
Величину $k$ обычно называют лагом (сдвигом). 
Часто сезонность можно определить визуально, рассматривая поведение членов ряда через каждые k временных единиц.

Автокорреляционная коррелограмма. Сезонные составляющие временного ряда могут быть найдены с помощью коррелограммы. Коррелограмма (автокоррелограмма) показывает численно и графически автокорреляционную функцию (AКФ), иными словами коэффициенты автокорреляции (и их стандартные ошибки) для последовательности лагов из определенного диапазона (например, от 1 до 30). На коррелограмме обычно отмечается диапазон в размере двух стандартных ошибок на каждом лаге, однако обычно величина автокорреляции более интересна, чем ее надежность, потому что интерес в основном представляют очень сильные (а, следовательно, высоко значимые) автокорреляции (см. Элементарные понятия статистики).

Исследование коррелограмм. При изучении коррелограмм следует помнить, что автокорреляции последовательных лагов формально зависимы между собой. Рассмотрим следующий пример. Если первый член ряда тесно связан со вторым, а второй с третьим, то первый элемент должен также каким-то образом зависеть от третьего и т.д. Это приводит к тому, что периодическая зависимость может существенно измениться после удаления автокорреляций первого порядка, т.е. после взятия разности с лагом 1).

Автокоррелограмма до и после взятия разности ряда

Частные автокорреляции. Другой полезный метод исследования периодичности состоит в исследовании частной автокорреляционной функции (ЧАКФ), представляющей собой углубление понятия обычной автокорреляционной функции. В ЧАКФ устраняется зависимость между промежуточными наблюдениями (наблюдениями внутри лага). Другими словами, частная автокорреляция на данном лаге аналогична обычной автокорреляции, за исключением того, что при вычислении из нее удаляется влияние автокорреляций с меньшими лагами (см. Бокс и Дженкинс, 1976; см. также McDowall, McCleary, Meidinger, and Hay, 1980). На лаге 1 (когда нет промежуточных элементов внутри лага), частная автокорреляция равна, очевидно, обычной автокорреляции. На самом деле, частная автокорреляция дает более "чистую" картину периодических зависимостей.

Удаление периодической зависимости. Как отмечалось выше, периодическая составляющая для данного лага k может быть удалена взятием разности соответствующего порядка. Это означает, что из каждого i-го элемента ряда вычитается (i-k)-й элемент. Имеются два довода в пользу таких преобразований.

Во-первых, таким образом можно определить скрытые периодические составляющие ряда. Напомним, что автокорреляции на последовательных лагах зависимы. Поэтому удаление некоторых автокорреляций изменит другие автокорреляции, которые, возможно, подавляли их, и сделает некоторые другие сезонные составляющие более заметными.

Во-вторых, удаление сезонных составляющих делает ряд стационарным, что необходимо для применения АРПСС и других методов, например, спектрального анализа.

I. Метод абсолютных разностей


Решение любой задачи по анализу и прогнозированию временных рядов начинается с построения графика исследуемого показателя. 

На стадии графического анализа можно определить характер сезонных колебаний: аддитивный или мультипликативный.
Отличительной особенностью аддитивной модели является то, что амплитуда сезонных
колебаний, отражающая отклонения от тренда или среднего, остается примерно постоянной,
неизменной во времени.

На стадии проведения графического анализа можно исследовать компонентный состав временных рядов, а также сделать первые шаги к выбору модели для описания их динамики и последующего прогнозирования.





Если присутствие тренда во временном ряду прослеживается нечетко, то прежде чем перейти к определению тенденции и выделению тренда, нужно выяснить, существует ли
вообще тенденция в исследуемом процессе.


Основные подходы к решению этой задачи основаны на статистической проверке гипотез.
Критерии выявления компонент ряда основаны на проверке гипотезы о случайности ряда.
Среди наиболее часто используемых на практике подходов для проверки наличия или
отсутствия тренда следует отметить метод Фостера-Стюарта







\section{Прогнозирование на основе  экспоненциального сглаживания}

\subsection{Простое экспоненциальное сглаживание}
$$
  \hat{y}_i = \alpha Y_i + (1-\alpha) \hat{y}_{t-1}
$$







\section{Стационарные временные ряды}


На практике, как правило, имеется один единственный отрезок реализации стохастического процесса~--- временной ряд, поэтому говорить об оценивании совокупности всех функций распределения не приходится. 
Кроме того, интуитивно понятно, что если основные статистические характеристики со временем меняются, то мы по короткому кусочку наших наблюдений вообще ничего не сможем сказать о нем. 
Поэтому на стохастические процессы, порождающие исследуемые временные ряды накладывают дополнительные ограничения. 
Обычным является рассмотрение стационарных случайныx процессов. 


Ряд $Y_t$ называется \emph{строго стационарным} (\emph{стационарным в узком смысле}), если сдвиг во времени не меняет ни одну из функций распределения, то есть совместное распределение вероятностей $m$ наблюдений
$$
(Y_{t_1}, Y_{t_2}, \ldots, Y_{t_m}) \sim (Y_{t_1+\tau}, Y_{t_2+\tau},, \ldots, Y_{t_m+\tau})
$$
для любых значений $m, \tau, t_1,t_2,\ldots, t_m$.

Свойства строго стационарного процесса не меняются при изменении начала отсчета, числовые характеристики такого процесса неизменны.

С практической точки зрения стационарность временного ряда означает:
\begin{itemize}
    \item отсутствие тренда;
    \item отсутствие систематических изменений дисперсии;
    \item отсутствие строго периодических флуктуаций;
    \item отсутствие систематически изменяющихся взаимозависимостей между уровнями временного ряда.
\end{itemize}

Большинство реальных экономических процессов не удовлетворяет свойствам стационарности.
Однако можно ввести понятие *эргодичности* (среднее арифметическое с течением времени сходится к математическому ожиданию), и тогда можно будет оценивать числовые характеристики стохастического
процесса по его реализации, т.е. по временному ряду.

Временной ряд $Y_t$ называется *слабо стационарным (стационарным в широком смысле, weak stationary)*, если его
теоретические математическое ожидание и дисперсия не зависят от времени, и если теоретическая ковариация между его значениями в моменты времени $t$ и $t+\tau$ зависят только от $\tau$, но не от $t$.
$$
    M(Y_t)= \mu, \qquad
    D(Y_t)= \gamma_0, \qquad
    \mathop{\mathrm{Cov}} (Y_t,Y_{t-\tau}) = \gamma_\tau
$$

Функцию
$$
\gamma_\tau = \mathop{\mathrm{Cov}}(Y_t,Y_{t-\tau}) = M\big((Y_t-\mu)(y_{t-\tau}-\mu)\big)
$$
называют *автоковариационной функцией*.

При $\tau=0$ значение $\gamma_\tau = D(Y_t)$.


**Утверждение.** *Из строгой стационарности стационарность, но не наоборот.*


\section{Примеры стационарных рядов}
\subsection{Белый шум}
Чисто случайный процесс, т.е. ряд независмых одинаково распределенных случайных величин с нулевым математическим ожиданием и постоянной дисперсией
$$
    Y_t = \varepsilon_t = iid(0,\sigma^2)
$$

\begin{verbatim}
# В R
WS <- rnorm(100, mean = 0, sd = 1)
ts.plot(WS, main = 'Белый шум', xlab = 'Время', ylab = '', col='blue', lwd = 2)
\end{verbatim}

\begin{verbatim}
# В Python
import numpy
import matplotlib.pyplot as plt

num_samples = 1000
WS = numpy.random.normal(0, 1, size=num_samples)

plt.plot(WS)
plt.show()
\end{verbatim}

\subsection{Процесс авторегрессии первого порядка AR(1)}
Задается рекуррентой
$$
    Y_t = m +  \varphi Y_{t-1} + \varepsilon_t
$$
\begin{itemize}
\item Если $|\varphi|<1$, то процесс стационарный:
$$
    \mu = \frac{m}{1-\varphi},\qquad \gamma_\tau = \varphi^\tau \sigma_y^2 = \varphi^\tau \frac{\sigma^2}{1-\varphi^2}
$$

При $m=0$ влияние возмущений затухает со временем:
$$
    Y_t = \varepsilon_t + \varphi\varepsilon_{t-1} + \varphi^2 \varepsilon_{t-2} + \ldots + \varphi^k\varepsilon_{t-k} + \ldots, \qquad \varphi^k\varepsilon_{t-k} \to 0
$$

\begin{verbatim}
AR=NULL
AR[1]=0
for (i in 2:100) {
   AR[i] = 0.5*AR[i-1] + rnorm(1,0,1)
}
ts.plot(AR, main = 'AR(1)', xlab = 'Время', ylab = '', col='blue', lwd = 2)
\end{verbatim}


\item Если $|\varphi| \geqslant 1$, то процесс **не стационарный**.

Например, при случайном блуждании $|\varphi|= 1$, $m=0$
$$
    M(Y_t) = M(Y_{t-1}) + M(\varepsilon_t) = M(Y_{t-1}) = \mu
$$

$$
    D(Y_t)= D(Y_{t-1}) + D(\varepsilon_t) = D(Y_{t-1})+ \sigma^2 \neq D(Y_{t-1})
$$

При $m=0$ влияние возмущений не затухает со временем:
$$
    Y_t = \varepsilon_t + \varepsilon_{t-1} + \varepsilon_{t-2} + \ldots + \varepsilon_{t-k} + \ldots
$$

\begin{verbatim}
RW = NULL
RW[1] = 0
for (i in 2:100) {
   RW[i] = RW[i-1] + rnorm(1,0,1)
}
ts.plot(RW, main = 'Случайное блуждание', xlab = 'Время', ylab = '', col='blue', lwd = 2)
\end{verbatim}

При случайном блуждании с дрейфом $|\varphi|= 1$, $m \neq 0$
$$
    M(Y_t) = m + M(Y_{t-1}) + M(\varepsilon_t) = m + M(Y_{t-1}) \neq M(Y_{t-1})
$$

$$
    D(Y_t)= D(Y_{t-1}) + D(\varepsilon_t) = D(Y_{t-1})+ \sigma^2 \neq D(Y_{t-1})
$$

При случайном блуждании с дрейфом имеет место тренд

\begin{verbatim}
RWD=NULL
RWD[1]=0
for (i in 2:100) {
   RWD[i] = 0.5 + RWD[i-1] + rnorm(1,0,1)
}
ts.plot(RWD, main = 'Случайное блуждание с дрейфом', xlab = 'Время', ylab = '', col='blue', lwd = 2)
\end{verbatim}

\end{itemize}
Существует несколько подходов к распознаванию стационарности:


\begin{itemize}
\item графическое представление временного ряда и визуальная проверка на наличие тренда;
\item исследование на наличие автокорреляции;
\item тесты на присутствие детерминистского тренда;
\item тесты на наличие стохастического тренда (например, тесты на единичный корень).
\end{itemize}

\section{Автокорреляция и ее график}
Рассмотрим функцию сопоставляющую каждому лагу $\tau$ значение коэффициента корреляции между временным рядом $Y_t$ и $Y_{t-\tau}$
$$
\rho_\tau  =  \frac{\mathop{\mathrm{Cov}} (Y_t,Y_{t-\tau})}{D(Y_t)} = \frac{\gamma_\tau}{\gamma_0}
$$

Она называется автокорреляционной функцией и обозначается $ACF(\tau)$.

Автокорреляционные функции для стационарных процессов быстро убывают.

\begin{itemize}
\item Для вычисления функции автокорреляции:
	\begin{itemize}
    \item в R используется функция\verb`acf(Y, lags, type= "correlation", pl=FALSE)` пакета\verb`library(tseries)`
    \item в Python используется\verb`statsmodels.tsa.stattools.acf(x,lags,alpha)`
	\end{itemize}


\item Для построения корелограммы
	\begin{itemize}
    \item в R используется \verb`acf(Y, lags, type= "correlation", pl=TRUE)` пакета\verb`library(tseries)`
    \item в Python используется \verb`statsmodels.graphics.tsaplots.plot_acf(x,lags,alpha)`
	\end{itemize}

\end{itemize}


\section{Частная автокорреляция и ее график}
Частная автокорреляция $PACF(\tau)$ показывает «чистую» корреляцию между уровнями $Y_t$ и $Y_{t-\tau}$7 временного ряда при исключении влияния промежуточных значений.

Частная автокорреляция вычисляется как МНК оценка коэффициента $\beta_\tau$
 в регрессии:
 $$
    Y_t = \beta_0 + \beta_1 Y_{t-1} +   \beta_2 Y_{t-2} +  \beta_\tau Y_{t-\tau} + \varepsilon_t
 $$

Частные автокорреляционные функции для стационарных процессов также быстро убывают.


Автокорреляционные функции для стационарных процессов быстро убывают.

\begin{itemize}
\item Для вычисления функции частной автокорреляции:
	\begin{itemize}
    \item в R используется функция\verb`acf(Y, lags, type= "partial", pl=FALSE)` пакета\verb`library(tseries)`
    \item в Python используется\verb`statsmodels.tsa.stattools.pacf(x,lags,alpha)`
	\end{itemize}


\item Для построения корелограммы
	\begin{itemize}
    \item в R используется \verb`acf(Y, lags, type= "partial", pl=TRUE)` пакета\verb`library(tseries)`
    \item в Python используется \verb`statsmodels.graphics.tsaplots.plot_pacf(x,lags,alpha)`
	\end{itemize}
\end{itemize}

\subsection{Тестирование нестационарности}

\subsubsection{Статистика Бокса-Пирса (Box, Pierce, 1970): для тестирования на белый шум}
Нулевая гипотеза заключается в том, что рассматриваемый процесс является белым шумом.
Точнее (для некоторого K > 0) проверяется гипотеза:
$$
	H_0'\colon  \rho_1 = \rho_2 = \ldots = \rho_K = 0.
$$

Строится статистика Бокса-Пирса
$$
    Q=T\sum_{\tau=1}^p r^2_\tau
$$
или статистика Лунга-Бокса
$$
    Q=T(T+2)\sum_{\tau=1}^p \frac{r^2_\tau}{T-\tau}
$$

Эти статистика имеет хи-квадрат распределения с $p$ степенями свободы.

Если наблюдаемое значение статистик превосходит критическую точку хи-квадрат распределения, то нулевая гипотеза отвергается.

Отметим, что Q-статистики являются асимптотическими и, следовательно, применимы  только для больших выборок.



Для тестов Бокса-Пирса и  Лунга-Бокса
\begin{itemize}
\item в R используется функция:

\verb`Box.test(x, lag = 1, type = c("Box-Pierce", "Ljung-Box"), fitdf = 0)`
где
\begin{itemize}
	\item $x$~--- временной ряд.
	\item $lag$~--- число лагов .
	\item $type$~--- типы теста, которые необходимо выполнить
	\item $fitdf$~--- число степеней свободы, которые нужно вычесть, если $x$~---  это ряд остатков.
\end{itemize}

\item В Python:

\verb'statsmodels.api.stats.acorr_ljungbox(x, lags=None, boxpierce=False, model_df=0)'
где
\begin{itemize}
	\item $x$~--- временной ряд.
	\item $lags$~--- число лагов .
	\item $boxpierce$~--- True, если требуется  тестов Бокса-Пирса, иначе вычисляется статистика  Лунга-Бокса
	\item $model\_df$~--- число степеней свободы, которые нужно вычесть, если $x$~---  это ряд остатков.
\end{itemize}
\end{itemize}
\subsubsection{Тест Дики-Фуллера (Dickey, Fuller, 1976) на наличие единичного корня}

$$
    X_t = \beta_0 + \beta_1 X_{t-1}  \varepsilon_t
$$
$$
    H_0 : \beta_1 =1, \qquad   H_1: \beta_1 < 1
$$

$$
    X_t-X_{t-1} = \beta_0 + (\beta_1-1)X_{t-1} + \varepsilon_t
$$



$$
   \Delta Y_t = Y_t-Y_{t-1} = \beta_0 + \delta Y_{t-1} + \varepsilon_t
$$






Существует три версии теста :
\begin{itemize}
\item Без константы и тренда $\Delta Y_{t} = \delta \cdot Y_{t-1}+\varepsilon_{t}$
\item С константой, но без тренда: $\Delta Y_{t} = \beta_{0} + \delta \cdot Y_{t-1}+ \varepsilon_{t}$.
\item С константой и линейным трендом: $ \Delta Y_{t} = \beta_{0}  \beta_1\cdot t + \delta \cdot Y_{t-1}+\varepsilon_{t}$.
\end{itemize}

Гипотезы:

$$
    H_0 : \delta = 0, \qquad   H_1: \delta < 0
$$



Рассмотрим статистический критерий
$$
t = \frac{\delta}{\sigma_\delta}
$$
По форме это обычная $t$-статистика для проверки значимости коэффициентов линейной регрессии.
Однако, распределение данной статистики   не совпадает с распределением статистики Стьюдента  и называется распределением Дики — Фуллера.
Для каждой версии теста должны использоваться специальыне таблицы.

Так как конкурирующая гипотеза левосторонняя $H_0$ отвергается,  если $t<t_\text{крит.}$


Тест Дики – Фуллера можно провести только в том случае, если ошибки регрессии не коррелируют и в правой части только первый лаг $Y$.
В противном случае применяется расширенный тест Дики и Фуллера с использованием тех же критических значений тестовой статистики.

$$
    \Delta Y_{t} = \beta_{0}  \beta_1\cdot t + \delta \cdot Y_{t-1}+ \sum_{i=1}^m \alpha_i \Delta X_{t-i} +  \varepsilon_{t}
$$

\paragraph{Расширенный тест Дики – Фуллера}
\begin{itemize}
    \item в R используется функция \verb`adf.test(Н)` пакета\verb`library(tseries)`
    \item в Python используется \verb`statsmodels.tsa.stattools.adfuller(Y)`
\end{itemize}



\section{Модели авторегрессии}

\begin{itemize}
\item AR(1)
	\begin{itemize}
    \item Автокорреляционная функция экспоненциально затухает, не меняя знака, если оценка параметра авторегрессии положительная, и – меняя знак, если отрицательна.
    \item Частная автокорреляционная функция имеет выброс на лаге 1, для других задержек – корреляции нет (PACF=0 для k>1).
	\end{itemize}

\item AR(2)
	\begin{itemize}
    \item условия стационарности: $\varphi_2 < 1$, $\varphi_1+ \varphi_2<1$, $\varphi_2-\varphi_1<1$
    \item Автокорреляционная функция процесса AR(2) может экспоненциально затухать, или может иметь форму затухающей синусоидальной волны.
    \item Частная автокорреляционная функция имеет выброс на лагах 1 и 2, для других задержек – корреляции нет (PACF=0 для k>2).
	\end{itemize}

\item MA(1)
	\begin{itemize}
    \item ACF имеет выброс на лаге 1;
    \item PACF экспоненциально затухает либо монотонно, либо меняя знак.
	\end{itemize}

\item MA($q$)
	\begin{itemize}
    \item ACF обрывается на лаге $q$.
	\end{itemize}
\end{itemize}


\end{document}
